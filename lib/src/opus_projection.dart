// ignore_for_file: always_specify_types
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

import 'dynamic_library.dart';

/// Bindings for `src/opus/include/opus_projection.h`.
///
/// Regenerate bindings with `dart run ffigen --config ffigen.yaml`.
///
class OpusProjection {
  /// Holds the symbol lookup function.
  ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      get _lookup => dylib.lookup;

  /// Gets the size of an OpusProjectionEncoder structure.
  /// @param channels <tt>int</tt>: The total number of input channels to encode.
  /// This must be no more than 255.
  /// @param mapping_family <tt>int</tt>: The mapping family to use for selecting
  /// the appropriate projection.
  /// @returns The size in bytes on success, or a negative error code
  /// (see @ref opus_errorcodes) on error.
  int opus_projection_ambisonics_encoder_get_size(
    int channels,
    int mapping_family,
  ) {
    return _opus_projection_ambisonics_encoder_get_size(
      channels,
      mapping_family,
    );
  }

  late final _opus_projection_ambisonics_encoder_get_sizePtr =
      _lookup<ffi.NativeFunction<opus_int32 Function(ffi.Int, ffi.Int)>>(
          'opus_projection_ambisonics_encoder_get_size');
  late final _opus_projection_ambisonics_encoder_get_size =
      _opus_projection_ambisonics_encoder_get_sizePtr
          .asFunction<int Function(int, int)>();

  /// Allocates and initializes a projection encoder state.
  /// Call opus_projection_encoder_destroy() to release
  /// this object when finished.
  /// @param Fs <tt>opus_int32</tt>: Sampling rate of the input signal (in Hz).
  /// This must be one of 8000, 12000, 16000,
  /// 24000, or 48000.
  /// @param channels <tt>int</tt>: Number of channels in the input signal.
  /// This must be at most 255.
  /// It may be greater than the number of
  /// coded channels (<code>streams +
  /// coupled_streams</code>).
  /// @param mapping_family <tt>int</tt>: The mapping family to use for selecting
  /// the appropriate projection.
  /// @param[out] streams <tt>int *</tt>: The total number of streams that will
  /// be encoded from the input.
  /// @param[out] coupled_streams <tt>int *</tt>: Number of coupled (2 channel)
  /// streams that will be encoded from the input.
  /// @param application <tt>int</tt>: The target encoder application.
  /// This must be one of the following:
  /// <dl>
  /// <dt>#OPUS_APPLICATION_VOIP</dt>
  /// <dd>Process signal for improved speech intelligibility.</dd>
  /// <dt>#OPUS_APPLICATION_AUDIO</dt>
  /// <dd>Favor faithfulness to the original input.</dd>
  /// <dt>#OPUS_APPLICATION_RESTRICTED_LOWDELAY</dt>
  /// <dd>Configure the minimum possible coding delay by disabling certain modes
  /// of operation.</dd>
  /// </dl>
  /// @param[out] error <tt>int *</tt>: Returns #OPUS_OK on success, or an error
  /// code (see @ref opus_errorcodes) on
  /// failure.
  ffi.Pointer<OpusProjectionEncoder> opus_projection_ambisonics_encoder_create(
    int Fs,
    int channels,
    int mapping_family,
    ffi.Pointer<ffi.Int> streams,
    ffi.Pointer<ffi.Int> coupled_streams,
    int application,
    ffi.Pointer<ffi.Int> error,
  ) {
    return _opus_projection_ambisonics_encoder_create(
      Fs,
      channels,
      mapping_family,
      streams,
      coupled_streams,
      application,
      error,
    );
  }

  late final _opus_projection_ambisonics_encoder_createPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<OpusProjectionEncoder> Function(
                  opus_int32,
                  ffi.Int,
                  ffi.Int,
                  ffi.Pointer<ffi.Int>,
                  ffi.Pointer<ffi.Int>,
                  ffi.Int,
                  ffi.Pointer<ffi.Int>)>>(
      'opus_projection_ambisonics_encoder_create');
  late final _opus_projection_ambisonics_encoder_create =
      _opus_projection_ambisonics_encoder_createPtr.asFunction<
          ffi.Pointer<OpusProjectionEncoder> Function(
              int,
              int,
              int,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              int,
              ffi.Pointer<ffi.Int>)>();

  /// Initialize a previously allocated projection encoder state.
  /// The memory pointed to by \a st must be at least the size returned by
  /// opus_projection_ambisonics_encoder_get_size().
  /// This is intended for applications which use their own allocator instead of
  /// malloc.
  /// To reset a previously initialized state, use the #OPUS_RESET_STATE CTL.
  /// @see opus_projection_ambisonics_encoder_create
  /// @see opus_projection_ambisonics_encoder_get_size
  /// @param st <tt>OpusProjectionEncoder*</tt>: Projection encoder state to initialize.
  /// @param Fs <tt>opus_int32</tt>: Sampling rate of the input signal (in Hz).
  /// This must be one of 8000, 12000, 16000,
  /// 24000, or 48000.
  /// @param channels <tt>int</tt>: Number of channels in the input signal.
  /// This must be at most 255.
  /// It may be greater than the number of
  /// coded channels (<code>streams +
  /// coupled_streams</code>).
  /// @param streams <tt>int</tt>: The total number of streams to encode from the
  /// input.
  /// This must be no more than the number of channels.
  /// @param coupled_streams <tt>int</tt>: Number of coupled (2 channel) streams
  /// to encode.
  /// This must be no larger than the total
  /// number of streams.
  /// Additionally, The total number of
  /// encoded channels (<code>streams +
  /// coupled_streams</code>) must be no
  /// more than the number of input channels.
  /// @param application <tt>int</tt>: The target encoder application.
  /// This must be one of the following:
  /// <dl>
  /// <dt>#OPUS_APPLICATION_VOIP</dt>
  /// <dd>Process signal for improved speech intelligibility.</dd>
  /// <dt>#OPUS_APPLICATION_AUDIO</dt>
  /// <dd>Favor faithfulness to the original input.</dd>
  /// <dt>#OPUS_APPLICATION_RESTRICTED_LOWDELAY</dt>
  /// <dd>Configure the minimum possible coding delay by disabling certain modes
  /// of operation.</dd>
  /// </dl>
  /// @returns #OPUS_OK on success, or an error code (see @ref opus_errorcodes)
  /// on failure.
  int opus_projection_ambisonics_encoder_init(
    ffi.Pointer<OpusProjectionEncoder> st,
    int Fs,
    int channels,
    int mapping_family,
    ffi.Pointer<ffi.Int> streams,
    ffi.Pointer<ffi.Int> coupled_streams,
    int application,
  ) {
    return _opus_projection_ambisonics_encoder_init(
      st,
      Fs,
      channels,
      mapping_family,
      streams,
      coupled_streams,
      application,
    );
  }

  late final _opus_projection_ambisonics_encoder_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<OpusProjectionEncoder>,
              opus_int32,
              ffi.Int,
              ffi.Int,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Int)>>('opus_projection_ambisonics_encoder_init');
  late final _opus_projection_ambisonics_encoder_init =
      _opus_projection_ambisonics_encoder_initPtr.asFunction<
          int Function(ffi.Pointer<OpusProjectionEncoder>, int, int, int,
              ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>, int)>();

  /// Encodes a projection Opus frame.
  /// @param st <tt>OpusProjectionEncoder*</tt>: Projection encoder state.
  /// @param[in] pcm <tt>const opus_int16*</tt>: The input signal as interleaved
  /// samples.
  /// This must contain
  /// <code>frame_size*channels</code>
  /// samples.
  /// @param frame_size <tt>int</tt>: Number of samples per channel in the input
  /// signal.
  /// This must be an Opus frame size for the
  /// encoder's sampling rate.
  /// For example, at 48 kHz the permitted values
  /// are 120, 240, 480, 960, 1920, and 2880.
  /// Passing in a duration of less than 10 ms
  /// (480 samples at 48 kHz) will prevent the
  /// encoder from using the LPC or hybrid modes.
  /// @param[out] data <tt>unsigned char*</tt>: Output payload.
  /// This must contain storage for at
  /// least \a max_data_bytes.
  /// @param [in] max_data_bytes <tt>opus_int32</tt>: Size of the allocated
  /// memory for the output
  /// payload. This may be
  /// used to impose an upper limit on
  /// the instant bitrate, but should
  /// not be used as the only bitrate
  /// control. Use #OPUS_SET_BITRATE to
  /// control the bitrate.
  /// @returns The length of the encoded packet (in bytes) on success or a
  /// negative error code (see @ref opus_errorcodes) on failure.
  int opus_projection_encode(
    ffi.Pointer<OpusProjectionEncoder> st,
    ffi.Pointer<opus_int16> pcm,
    int frame_size,
    ffi.Pointer<ffi.UnsignedChar> data,
    int max_data_bytes,
  ) {
    return _opus_projection_encode(
      st,
      pcm,
      frame_size,
      data,
      max_data_bytes,
    );
  }

  late final _opus_projection_encodePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<OpusProjectionEncoder>,
              ffi.Pointer<opus_int16>,
              ffi.Int,
              ffi.Pointer<ffi.UnsignedChar>,
              opus_int32)>>('opus_projection_encode');
  late final _opus_projection_encode = _opus_projection_encodePtr.asFunction<
      int Function(ffi.Pointer<OpusProjectionEncoder>, ffi.Pointer<opus_int16>,
          int, ffi.Pointer<ffi.UnsignedChar>, int)>();

  /// Encodes a projection Opus frame.
  /// @param st <tt>OpusProjectionEncoder*</tt>: Projection encoder state.
  /// @param[in] pcm <tt>const opus_int32*</tt>: The input signal as interleaved
  /// samples representing (or slightly exceeding) 24-bit values.
  /// This must contain
  /// <code>frame_size*channels</code>
  /// samples.
  /// @param frame_size <tt>int</tt>: Number of samples per channel in the input
  /// signal.
  /// This must be an Opus frame size for the
  /// encoder's sampling rate.
  /// For example, at 48 kHz the permitted values
  /// are 120, 240, 480, 960, 1920, and 2880.
  /// Passing in a duration of less than 10 ms
  /// (480 samples at 48 kHz) will prevent the
  /// encoder from using the LPC or hybrid modes.
  /// @param[out] data <tt>unsigned char*</tt>: Output payload.
  /// This must contain storage for at
  /// least \a max_data_bytes.
  /// @param [in] max_data_bytes <tt>opus_int32</tt>: Size of the allocated
  /// memory for the output
  /// payload. This may be
  /// used to impose an upper limit on
  /// the instant bitrate, but should
  /// not be used as the only bitrate
  /// control. Use #OPUS_SET_BITRATE to
  /// control the bitrate.
  /// @returns The length of the encoded packet (in bytes) on success or a
  /// negative error code (see @ref opus_errorcodes) on failure.
  int opus_projection_encode24(
    ffi.Pointer<OpusProjectionEncoder> st,
    ffi.Pointer<opus_int32> pcm,
    int frame_size,
    ffi.Pointer<ffi.UnsignedChar> data,
    int max_data_bytes,
  ) {
    return _opus_projection_encode24(
      st,
      pcm,
      frame_size,
      data,
      max_data_bytes,
    );
  }

  late final _opus_projection_encode24Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<OpusProjectionEncoder>,
              ffi.Pointer<opus_int32>,
              ffi.Int,
              ffi.Pointer<ffi.UnsignedChar>,
              opus_int32)>>('opus_projection_encode24');
  late final _opus_projection_encode24 =
      _opus_projection_encode24Ptr.asFunction<
          int Function(
              ffi.Pointer<OpusProjectionEncoder>,
              ffi.Pointer<opus_int32>,
              int,
              ffi.Pointer<ffi.UnsignedChar>,
              int)>();

  /// Encodes a projection Opus frame from floating point input.
  /// @param st <tt>OpusProjectionEncoder*</tt>: Projection encoder state.
  /// @param[in] pcm <tt>const float*</tt>: The input signal as interleaved
  /// samples with a normal range of
  /// +/-1.0.
  /// Samples with a range beyond +/-1.0
  /// are supported but will be clipped by
  /// decoders using the integer API and
  /// should only be used if it is known
  /// that the far end supports extended
  /// dynamic range.
  /// This must contain
  /// <code>frame_size*channels</code>
  /// samples.
  /// @param frame_size <tt>int</tt>: Number of samples per channel in the input
  /// signal.
  /// This must be an Opus frame size for the
  /// encoder's sampling rate.
  /// For example, at 48 kHz the permitted values
  /// are 120, 240, 480, 960, 1920, and 2880.
  /// Passing in a duration of less than 10 ms
  /// (480 samples at 48 kHz) will prevent the
  /// encoder from using the LPC or hybrid modes.
  /// @param[out] data <tt>unsigned char*</tt>: Output payload.
  /// This must contain storage for at
  /// least \a max_data_bytes.
  /// @param [in] max_data_bytes <tt>opus_int32</tt>: Size of the allocated
  /// memory for the output
  /// payload. This may be
  /// used to impose an upper limit on
  /// the instant bitrate, but should
  /// not be used as the only bitrate
  /// control. Use #OPUS_SET_BITRATE to
  /// control the bitrate.
  /// @returns The length of the encoded packet (in bytes) on success or a
  /// negative error code (see @ref opus_errorcodes) on failure.
  int opus_projection_encode_float(
    ffi.Pointer<OpusProjectionEncoder> st,
    ffi.Pointer<ffi.Float> pcm,
    int frame_size,
    ffi.Pointer<ffi.UnsignedChar> data,
    int max_data_bytes,
  ) {
    return _opus_projection_encode_float(
      st,
      pcm,
      frame_size,
      data,
      max_data_bytes,
    );
  }

  late final _opus_projection_encode_floatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<OpusProjectionEncoder>,
              ffi.Pointer<ffi.Float>,
              ffi.Int,
              ffi.Pointer<ffi.UnsignedChar>,
              opus_int32)>>('opus_projection_encode_float');
  late final _opus_projection_encode_float =
      _opus_projection_encode_floatPtr.asFunction<
          int Function(
              ffi.Pointer<OpusProjectionEncoder>,
              ffi.Pointer<ffi.Float>,
              int,
              ffi.Pointer<ffi.UnsignedChar>,
              int)>();

  /// Frees an <code>OpusProjectionEncoder</code> allocated by
  /// opus_projection_ambisonics_encoder_create().
  /// @param st <tt>OpusProjectionEncoder*</tt>: Projection encoder state to be freed.
  void opus_projection_encoder_destroy(
    ffi.Pointer<OpusProjectionEncoder> st,
  ) {
    return _opus_projection_encoder_destroy(
      st,
    );
  }

  late final _opus_projection_encoder_destroyPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<OpusProjectionEncoder>)>>(
      'opus_projection_encoder_destroy');
  late final _opus_projection_encoder_destroy =
      _opus_projection_encoder_destroyPtr
          .asFunction<void Function(ffi.Pointer<OpusProjectionEncoder>)>();

  /// Perform a CTL function on a projection Opus encoder.
  ///
  /// Generally the request and subsequent arguments are generated by a
  /// convenience macro.
  /// @param st <tt>OpusProjectionEncoder*</tt>: Projection encoder state.
  /// @param request This and all remaining parameters should be replaced by one
  /// of the convenience macros in @ref opus_genericctls,
  /// @ref opus_encoderctls, @ref opus_multistream_ctls, or
  /// @ref opus_projection_ctls
  /// @see opus_genericctls
  /// @see opus_encoderctls
  /// @see opus_multistream_ctls
  /// @see opus_projection_ctls
  int opus_projection_encoder_ctl(
    ffi.Pointer<OpusProjectionEncoder> st,
    int request,
  ) {
    return _opus_projection_encoder_ctl(
      st,
      request,
    );
  }

  late final _opus_projection_encoder_ctlPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<OpusProjectionEncoder>,
              ffi.Int)>>('opus_projection_encoder_ctl');
  late final _opus_projection_encoder_ctl = _opus_projection_encoder_ctlPtr
      .asFunction<int Function(ffi.Pointer<OpusProjectionEncoder>, int)>();

  /// Gets the size of an <code>OpusProjectionDecoder</code> structure.
  /// @param channels <tt>int</tt>: The total number of output channels.
  /// This must be no more than 255.
  /// @param streams <tt>int</tt>: The total number of streams coded in the
  /// input.
  /// This must be no more than 255.
  /// @param coupled_streams <tt>int</tt>: Number streams to decode as coupled
  /// (2 channel) streams.
  /// This must be no larger than the total
  /// number of streams.
  /// Additionally, The total number of
  /// coded channels (<code>streams +
  /// coupled_streams</code>) must be no
  /// more than 255.
  /// @returns The size in bytes on success, or a negative error code
  /// (see @ref opus_errorcodes) on error.
  int opus_projection_decoder_get_size(
    int channels,
    int streams,
    int coupled_streams,
  ) {
    return _opus_projection_decoder_get_size(
      channels,
      streams,
      coupled_streams,
    );
  }

  late final _opus_projection_decoder_get_sizePtr = _lookup<
          ffi.NativeFunction<opus_int32 Function(ffi.Int, ffi.Int, ffi.Int)>>(
      'opus_projection_decoder_get_size');
  late final _opus_projection_decoder_get_size =
      _opus_projection_decoder_get_sizePtr
          .asFunction<int Function(int, int, int)>();

  /// Allocates and initializes a projection decoder state.
  /// Call opus_projection_decoder_destroy() to release
  /// this object when finished.
  /// @param Fs <tt>opus_int32</tt>: Sampling rate to decode at (in Hz).
  /// This must be one of 8000, 12000, 16000,
  /// 24000, or 48000.
  /// @param channels <tt>int</tt>: Number of channels to output.
  /// This must be at most 255.
  /// It may be different from the number of coded
  /// channels (<code>streams +
  /// coupled_streams</code>).
  /// @param streams <tt>int</tt>: The total number of streams coded in the
  /// input.
  /// This must be no more than 255.
  /// @param coupled_streams <tt>int</tt>: Number of streams to decode as coupled
  /// (2 channel) streams.
  /// This must be no larger than the total
  /// number of streams.
  /// Additionally, The total number of
  /// coded channels (<code>streams +
  /// coupled_streams</code>) must be no
  /// more than 255.
  /// @param[in] demixing_matrix <tt>const unsigned char[demixing_matrix_size]</tt>: Demixing matrix
  /// that mapping from coded channels to output channels,
  /// as described in @ref opus_projection and
  /// @ref opus_projection_ctls.
  /// @param demixing_matrix_size <tt>opus_int32</tt>: The size in bytes of the
  /// demixing matrix, as
  /// described in @ref
  /// opus_projection_ctls.
  /// @param[out] error <tt>int *</tt>: Returns #OPUS_OK on success, or an error
  /// code (see @ref opus_errorcodes) on
  /// failure.
  ffi.Pointer<OpusProjectionDecoder> opus_projection_decoder_create(
    int Fs,
    int channels,
    int streams,
    int coupled_streams,
    ffi.Pointer<ffi.UnsignedChar> demixing_matrix,
    int demixing_matrix_size,
    ffi.Pointer<ffi.Int> error,
  ) {
    return _opus_projection_decoder_create(
      Fs,
      channels,
      streams,
      coupled_streams,
      demixing_matrix,
      demixing_matrix_size,
      error,
    );
  }

  late final _opus_projection_decoder_createPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OpusProjectionDecoder> Function(
              opus_int32,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Pointer<ffi.UnsignedChar>,
              opus_int32,
              ffi.Pointer<ffi.Int>)>>('opus_projection_decoder_create');
  late final _opus_projection_decoder_create =
      _opus_projection_decoder_createPtr.asFunction<
          ffi.Pointer<OpusProjectionDecoder> Function(int, int, int, int,
              ffi.Pointer<ffi.UnsignedChar>, int, ffi.Pointer<ffi.Int>)>();

  /// Initialize a previously allocated projection decoder state object.
  /// The memory pointed to by \a st must be at least the size returned by
  /// opus_projection_decoder_get_size().
  /// This is intended for applications which use their own allocator instead of
  /// malloc.
  /// To reset a previously initialized state, use the #OPUS_RESET_STATE CTL.
  /// @see opus_projection_decoder_create
  /// @see opus_projection_deocder_get_size
  /// @param st <tt>OpusProjectionDecoder*</tt>: Projection encoder state to initialize.
  /// @param Fs <tt>opus_int32</tt>: Sampling rate to decode at (in Hz).
  /// This must be one of 8000, 12000, 16000,
  /// 24000, or 48000.
  /// @param channels <tt>int</tt>: Number of channels to output.
  /// This must be at most 255.
  /// It may be different from the number of coded
  /// channels (<code>streams +
  /// coupled_streams</code>).
  /// @param streams <tt>int</tt>: The total number of streams coded in the
  /// input.
  /// This must be no more than 255.
  /// @param coupled_streams <tt>int</tt>: Number of streams to decode as coupled
  /// (2 channel) streams.
  /// This must be no larger than the total
  /// number of streams.
  /// Additionally, The total number of
  /// coded channels (<code>streams +
  /// coupled_streams</code>) must be no
  /// more than 255.
  /// @param[in] demixing_matrix <tt>const unsigned char[demixing_matrix_size]</tt>: Demixing matrix
  /// that mapping from coded channels to output channels,
  /// as described in @ref opus_projection and
  /// @ref opus_projection_ctls.
  /// @param demixing_matrix_size <tt>opus_int32</tt>: The size in bytes of the
  /// demixing matrix, as
  /// described in @ref
  /// opus_projection_ctls.
  /// @returns #OPUS_OK on success, or an error code (see @ref opus_errorcodes)
  /// on failure.
  int opus_projection_decoder_init(
    ffi.Pointer<OpusProjectionDecoder> st,
    int Fs,
    int channels,
    int streams,
    int coupled_streams,
    ffi.Pointer<ffi.UnsignedChar> demixing_matrix,
    int demixing_matrix_size,
  ) {
    return _opus_projection_decoder_init(
      st,
      Fs,
      channels,
      streams,
      coupled_streams,
      demixing_matrix,
      demixing_matrix_size,
    );
  }

  late final _opus_projection_decoder_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<OpusProjectionDecoder>,
              opus_int32,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Pointer<ffi.UnsignedChar>,
              opus_int32)>>('opus_projection_decoder_init');
  late final _opus_projection_decoder_init =
      _opus_projection_decoder_initPtr.asFunction<
          int Function(ffi.Pointer<OpusProjectionDecoder>, int, int, int, int,
              ffi.Pointer<ffi.UnsignedChar>, int)>();

  /// Decode a projection Opus packet.
  /// @param st <tt>OpusProjectionDecoder*</tt>: Projection decoder state.
  /// @param[in] data <tt>const unsigned char*</tt>: Input payload.
  /// Use a <code>NULL</code>
  /// pointer to indicate packet
  /// loss.
  /// @param len <tt>opus_int32</tt>: Number of bytes in payload.
  /// @param[out] pcm <tt>opus_int16*</tt>: Output signal, with interleaved
  /// samples.
  /// This must contain room for
  /// <code>frame_size*channels</code>
  /// samples.
  /// @param frame_size <tt>int</tt>: The number of samples per channel of
  /// available space in \a pcm.
  /// If this is less than the maximum packet duration
  /// (120 ms; 5760 for 48kHz), this function will not be capable
  /// of decoding some packets. In the case of PLC (data==NULL)
  /// or FEC (decode_fec=1), then frame_size needs to be exactly
  /// the duration of audio that is missing, otherwise the
  /// decoder will not be in the optimal state to decode the
  /// next incoming packet. For the PLC and FEC cases, frame_size
  /// <b>must</b> be a multiple of 2.5 ms.
  /// @param decode_fec <tt>int</tt>: Flag (0 or 1) to request that any in-band
  /// forward error correction data be decoded.
  /// If no such data is available, the frame is
  /// decoded as if it were lost.
  /// @returns Number of samples decoded on success or a negative error code
  /// (see @ref opus_errorcodes) on failure.
  int opus_projection_decode(
    ffi.Pointer<OpusProjectionDecoder> st,
    ffi.Pointer<ffi.UnsignedChar> data,
    int len,
    ffi.Pointer<opus_int16> pcm,
    int frame_size,
    int decode_fec,
  ) {
    return _opus_projection_decode(
      st,
      data,
      len,
      pcm,
      frame_size,
      decode_fec,
    );
  }

  late final _opus_projection_decodePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<OpusProjectionDecoder>,
              ffi.Pointer<ffi.UnsignedChar>,
              opus_int32,
              ffi.Pointer<opus_int16>,
              ffi.Int,
              ffi.Int)>>('opus_projection_decode');
  late final _opus_projection_decode = _opus_projection_decodePtr.asFunction<
      int Function(
          ffi.Pointer<OpusProjectionDecoder>,
          ffi.Pointer<ffi.UnsignedChar>,
          int,
          ffi.Pointer<opus_int16>,
          int,
          int)>();

  /// Decode a projection Opus packet.
  /// @param st <tt>OpusProjectionDecoder*</tt>: Projection decoder state.
  /// @param[in] data <tt>const unsigned char*</tt>: Input payload.
  /// Use a <code>NULL</code>
  /// pointer to indicate packet
  /// loss.
  /// @param len <tt>opus_int32</tt>: Number of bytes in payload.
  /// @param[out] pcm <tt>opus_int32*</tt>: Output signal, with interleaved
  /// samples representing (or slightly exceeding) 24-bit values.
  /// This must contain room for
  /// <code>frame_size*channels</code>
  /// samples.
  /// @param frame_size <tt>int</tt>: The number of samples per channel of
  /// available space in \a pcm.
  /// If this is less than the maximum packet duration
  /// (120 ms; 5760 for 48kHz), this function will not be capable
  /// of decoding some packets. In the case of PLC (data==NULL)
  /// or FEC (decode_fec=1), then frame_size needs to be exactly
  /// the duration of audio that is missing, otherwise the
  /// decoder will not be in the optimal state to decode the
  /// next incoming packet. For the PLC and FEC cases, frame_size
  /// <b>must</b> be a multiple of 2.5 ms.
  /// @param decode_fec <tt>int</tt>: Flag (0 or 1) to request that any in-band
  /// forward error correction data be decoded.
  /// If no such data is available, the frame is
  /// decoded as if it were lost.
  /// @returns Number of samples decoded on success or a negative error code
  /// (see @ref opus_errorcodes) on failure.
  int opus_projection_decode24(
    ffi.Pointer<OpusProjectionDecoder> st,
    ffi.Pointer<ffi.UnsignedChar> data,
    int len,
    ffi.Pointer<opus_int32> pcm,
    int frame_size,
    int decode_fec,
  ) {
    return _opus_projection_decode24(
      st,
      data,
      len,
      pcm,
      frame_size,
      decode_fec,
    );
  }

  late final _opus_projection_decode24Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<OpusProjectionDecoder>,
              ffi.Pointer<ffi.UnsignedChar>,
              opus_int32,
              ffi.Pointer<opus_int32>,
              ffi.Int,
              ffi.Int)>>('opus_projection_decode24');
  late final _opus_projection_decode24 =
      _opus_projection_decode24Ptr.asFunction<
          int Function(
              ffi.Pointer<OpusProjectionDecoder>,
              ffi.Pointer<ffi.UnsignedChar>,
              int,
              ffi.Pointer<opus_int32>,
              int,
              int)>();

  /// Decode a projection Opus packet with floating point output.
  /// @param st <tt>OpusProjectionDecoder*</tt>: Projection decoder state.
  /// @param[in] data <tt>const unsigned char*</tt>: Input payload.
  /// Use a <code>NULL</code>
  /// pointer to indicate packet
  /// loss.
  /// @param len <tt>opus_int32</tt>: Number of bytes in payload.
  /// @param[out] pcm <tt>opus_int16*</tt>: Output signal, with interleaved
  /// samples.
  /// This must contain room for
  /// <code>frame_size*channels</code>
  /// samples.
  /// @param frame_size <tt>int</tt>: The number of samples per channel of
  /// available space in \a pcm.
  /// If this is less than the maximum packet duration
  /// (120 ms; 5760 for 48kHz), this function will not be capable
  /// of decoding some packets. In the case of PLC (data==NULL)
  /// or FEC (decode_fec=1), then frame_size needs to be exactly
  /// the duration of audio that is missing, otherwise the
  /// decoder will not be in the optimal state to decode the
  /// next incoming packet. For the PLC and FEC cases, frame_size
  /// <b>must</b> be a multiple of 2.5 ms.
  /// @param decode_fec <tt>int</tt>: Flag (0 or 1) to request that any in-band
  /// forward error correction data be decoded.
  /// If no such data is available, the frame is
  /// decoded as if it were lost.
  /// @returns Number of samples decoded on success or a negative error code
  /// (see @ref opus_errorcodes) on failure.
  int opus_projection_decode_float(
    ffi.Pointer<OpusProjectionDecoder> st,
    ffi.Pointer<ffi.UnsignedChar> data,
    int len,
    ffi.Pointer<ffi.Float> pcm,
    int frame_size,
    int decode_fec,
  ) {
    return _opus_projection_decode_float(
      st,
      data,
      len,
      pcm,
      frame_size,
      decode_fec,
    );
  }

  late final _opus_projection_decode_floatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<OpusProjectionDecoder>,
              ffi.Pointer<ffi.UnsignedChar>,
              opus_int32,
              ffi.Pointer<ffi.Float>,
              ffi.Int,
              ffi.Int)>>('opus_projection_decode_float');
  late final _opus_projection_decode_float =
      _opus_projection_decode_floatPtr.asFunction<
          int Function(
              ffi.Pointer<OpusProjectionDecoder>,
              ffi.Pointer<ffi.UnsignedChar>,
              int,
              ffi.Pointer<ffi.Float>,
              int,
              int)>();

  /// Perform a CTL function on a projection Opus decoder.
  ///
  /// Generally the request and subsequent arguments are generated by a
  /// convenience macro.
  /// @param st <tt>OpusProjectionDecoder*</tt>: Projection decoder state.
  /// @param request This and all remaining parameters should be replaced by one
  /// of the convenience macros in @ref opus_genericctls,
  /// @ref opus_decoderctls, @ref opus_multistream_ctls, or
  /// @ref opus_projection_ctls.
  /// @see opus_genericctls
  /// @see opus_decoderctls
  /// @see opus_multistream_ctls
  /// @see opus_projection_ctls
  int opus_projection_decoder_ctl(
    ffi.Pointer<OpusProjectionDecoder> st,
    int request,
  ) {
    return _opus_projection_decoder_ctl(
      st,
      request,
    );
  }

  late final _opus_projection_decoder_ctlPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<OpusProjectionDecoder>,
              ffi.Int)>>('opus_projection_decoder_ctl');
  late final _opus_projection_decoder_ctl = _opus_projection_decoder_ctlPtr
      .asFunction<int Function(ffi.Pointer<OpusProjectionDecoder>, int)>();

  /// Frees an <code>OpusProjectionDecoder</code> allocated by
  /// opus_projection_decoder_create().
  /// @param st <tt>OpusProjectionDecoder</tt>: Projection decoder state to be freed.
  void opus_projection_decoder_destroy(
    ffi.Pointer<OpusProjectionDecoder> st,
  ) {
    return _opus_projection_decoder_destroy(
      st,
    );
  }

  late final _opus_projection_decoder_destroyPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<OpusProjectionDecoder>)>>(
      'opus_projection_decoder_destroy');
  late final _opus_projection_decoder_destroy =
      _opus_projection_decoder_destroyPtr
          .asFunction<void Function(ffi.Pointer<OpusProjectionDecoder>)>();
}

final class OpusProjectionEncoder extends ffi.Opaque {}

final class OpusProjectionDecoder extends ffi.Opaque {}

typedef opus_int32 = ffi.Int32;
typedef Dartopus_int32 = int;
typedef opus_int16 = ffi.Int16;
typedef Dartopus_int16 = int;

const int OPUS_PROJECTION_GET_DEMIXING_MATRIX_GAIN_REQUEST = 6001;

const int OPUS_PROJECTION_GET_DEMIXING_MATRIX_SIZE_REQUEST = 6003;

const int OPUS_PROJECTION_GET_DEMIXING_MATRIX_REQUEST = 6005;
