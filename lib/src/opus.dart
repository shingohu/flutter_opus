// ignore_for_file: always_specify_types
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

import 'dynamic_library.dart';

late final opus = Opus();

/// Bindings for `src/opus/include/opus.h`.
///
/// Regenerate bindings with `dart run ffigen --config ffigen.yaml`.
///
class Opus {
  /// Holds the symbol lookup function.
  ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      get _lookup => dylib.lookup;

  /// Gets the size of an <code>OpusEncoder</code> structure.
  /// @param[in] channels <tt>int</tt>: Number of channels.
  /// This must be 1 or 2.
  /// @returns The size in bytes.
  int opus_encoder_get_size(
    int channels,
  ) {
    return _opus_encoder_get_size(
      channels,
    );
  }

  late final _opus_encoder_get_sizePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          'opus_encoder_get_size');
  late final _opus_encoder_get_size =
      _opus_encoder_get_sizePtr.asFunction<int Function(int)>();

  /// Allocates and initializes an encoder state.
  /// There are three coding modes:
  ///
  /// @ref OPUS_APPLICATION_VOIP gives best quality at a given bitrate for voice
  /// signals. It enhances the  input signal by high-pass filtering and
  /// emphasizing formants and harmonics. Optionally  it includes in-band
  /// forward error correction to protect against packet loss. Use this
  /// mode for typical VoIP applications. Because of the enhancement,
  /// even at high bitrates the output may sound different from the input.
  ///
  /// @ref OPUS_APPLICATION_AUDIO gives best quality at a given bitrate for most
  /// non-voice signals like music. Use this mode for music and mixed
  /// (music/voice) content, broadcast, and applications requiring less
  /// than 15 ms of coding delay.
  ///
  /// @ref OPUS_APPLICATION_RESTRICTED_LOWDELAY configures low-delay mode that
  /// disables the speech-optimized mode in exchange for slightly reduced delay.
  /// This mode can only be set on an newly initialized or freshly reset encoder
  /// because it changes the codec delay.
  ///
  /// This is useful when the caller knows that the speech-optimized modes will not be needed (use with caution).
  /// @param [in] Fs <tt>opus_int32</tt>: Sampling rate of input signal (Hz)
  /// This must be one of 8000, 12000, 16000,
  /// 24000, or 48000.
  /// @param [in] channels <tt>int</tt>: Number of channels (1 or 2) in input signal
  /// @param [in] application <tt>int</tt>: Coding mode (one of @ref OPUS_APPLICATION_VOIP, @ref OPUS_APPLICATION_AUDIO, or @ref OPUS_APPLICATION_RESTRICTED_LOWDELAY)
  /// @param [out] error <tt>int*</tt>: @ref opus_errorcodes
  /// @note Regardless of the sampling rate and number channels selected, the Opus encoder
  /// can switch to a lower audio bandwidth or number of channels if the bitrate
  /// selected is too low. This also means that it is safe to always use 48 kHz stereo input
  /// and let the encoder optimize the encoding.
  ffi.Pointer<OpusEncoder> opus_encoder_create(
    int Fs,
    int channels,
    int application,
    ffi.Pointer<ffi.Int> error,
  ) {
    return _opus_encoder_create(
      Fs,
      channels,
      application,
      error,
    );
  }

  late final _opus_encoder_createPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OpusEncoder> Function(opus_int32, ffi.Int, ffi.Int,
              ffi.Pointer<ffi.Int>)>>('opus_encoder_create');
  late final _opus_encoder_create = _opus_encoder_createPtr.asFunction<
      ffi.Pointer<OpusEncoder> Function(int, int, int, ffi.Pointer<ffi.Int>)>();

  /// Initializes a previously allocated encoder state
  /// The memory pointed to by st must be at least the size returned by opus_encoder_get_size().
  /// This is intended for applications which use their own allocator instead of malloc.
  /// @see opus_encoder_create(),opus_encoder_get_size()
  /// To reset a previously initialized state, use the #OPUS_RESET_STATE CTL.
  /// @param [in] st <tt>OpusEncoder*</tt>: Encoder state
  /// @param [in] Fs <tt>opus_int32</tt>: Sampling rate of input signal (Hz)
  /// This must be one of 8000, 12000, 16000,
  /// 24000, or 48000.
  /// @param [in] channels <tt>int</tt>: Number of channels (1 or 2) in input signal
  /// @param [in] application <tt>int</tt>: Coding mode (one of OPUS_APPLICATION_VOIP, OPUS_APPLICATION_AUDIO, or OPUS_APPLICATION_RESTRICTED_LOWDELAY)
  /// @retval #OPUS_OK Success or @ref opus_errorcodes
  int opus_encoder_init(
    ffi.Pointer<OpusEncoder> st,
    int Fs,
    int channels,
    int application,
  ) {
    return _opus_encoder_init(
      st,
      Fs,
      channels,
      application,
    );
  }

  late final _opus_encoder_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<OpusEncoder>, opus_int32, ffi.Int,
              ffi.Int)>>('opus_encoder_init');
  late final _opus_encoder_init = _opus_encoder_initPtr
      .asFunction<int Function(ffi.Pointer<OpusEncoder>, int, int, int)>();

  /// Encodes an Opus frame.
  /// @param [in] st <tt>OpusEncoder*</tt>: Encoder state
  /// @param [in] pcm <tt>opus_int16*</tt>: Input signal (interleaved if 2 channels). length is frame_size*channels*sizeof(opus_int16)
  /// @param [in] frame_size <tt>int</tt>: Number of samples per channel in the
  /// input signal.
  /// This must be an Opus frame size for
  /// the encoder's sampling rate.
  /// For example, at 48 kHz the permitted
  /// values are 120, 240, 480, 960, 1920,
  /// and 2880.
  /// Passing in a duration of less than
  /// 10 ms (480 samples at 48 kHz) will
  /// prevent the encoder from using the LPC
  /// or hybrid modes.
  /// @param [out] data <tt>unsigned char*</tt>: Output payload.
  /// This must contain storage for at
  /// least \a max_data_bytes.
  /// @param [in] max_data_bytes <tt>opus_int32</tt>: Size of the allocated
  /// memory for the output
  /// payload. This may be
  /// used to impose an upper limit on
  /// the instant bitrate, but should
  /// not be used as the only bitrate
  /// control. Use #OPUS_SET_BITRATE to
  /// control the bitrate.
  /// @returns The length of the encoded packet (in bytes) on success or a
  /// negative error code (see @ref opus_errorcodes) on failure.
  int opus_encode(
    ffi.Pointer<OpusEncoder> st,
    ffi.Pointer<opus_int16> pcm,
    int frame_size,
    ffi.Pointer<ffi.UnsignedChar> data,
    int max_data_bytes,
  ) {
    return _opus_encode(
      st,
      pcm,
      frame_size,
      data,
      max_data_bytes,
    );
  }

  late final _opus_encodePtr = _lookup<
      ffi.NativeFunction<
          opus_int32 Function(
              ffi.Pointer<OpusEncoder>,
              ffi.Pointer<opus_int16>,
              ffi.Int,
              ffi.Pointer<ffi.UnsignedChar>,
              opus_int32)>>('opus_encode');
  late final _opus_encode = _opus_encodePtr.asFunction<
      int Function(ffi.Pointer<OpusEncoder>, ffi.Pointer<opus_int16>, int,
          ffi.Pointer<ffi.UnsignedChar>, int)>();

  /// Encodes an Opus frame.
  /// @param [in] st <tt>OpusEncoder*</tt>: Encoder state
  /// @param [in] pcm <tt>opus_int32*</tt>: Input signal (interleaved if 2 channels) representing (or slightly exceeding) 24-bit values. length is frame_size*channels*sizeof(opus_int32)
  /// @param [in] frame_size <tt>int</tt>: Number of samples per channel in the
  /// input signal.
  /// This must be an Opus frame size for
  /// the encoder's sampling rate.
  /// For example, at 48 kHz the permitted
  /// values are 120, 240, 480, 960, 1920,
  /// and 2880.
  /// Passing in a duration of less than
  /// 10 ms (480 samples at 48 kHz) will
  /// prevent the encoder from using the LPC
  /// or hybrid modes.
  /// @param [out] data <tt>unsigned char*</tt>: Output payload.
  /// This must contain storage for at
  /// least \a max_data_bytes.
  /// @param [in] max_data_bytes <tt>opus_int32</tt>: Size of the allocated
  /// memory for the output
  /// payload. This may be
  /// used to impose an upper limit on
  /// the instant bitrate, but should
  /// not be used as the only bitrate
  /// control. Use #OPUS_SET_BITRATE to
  /// control the bitrate.
  /// @returns The length of the encoded packet (in bytes) on success or a
  /// negative error code (see @ref opus_errorcodes) on failure.
  int opus_encode24(
    ffi.Pointer<OpusEncoder> st,
    ffi.Pointer<opus_int32> pcm,
    int frame_size,
    ffi.Pointer<ffi.UnsignedChar> data,
    int max_data_bytes,
  ) {
    return _opus_encode24(
      st,
      pcm,
      frame_size,
      data,
      max_data_bytes,
    );
  }

  late final _opus_encode24Ptr = _lookup<
      ffi.NativeFunction<
          opus_int32 Function(
              ffi.Pointer<OpusEncoder>,
              ffi.Pointer<opus_int32>,
              ffi.Int,
              ffi.Pointer<ffi.UnsignedChar>,
              opus_int32)>>('opus_encode24');
  late final _opus_encode24 = _opus_encode24Ptr.asFunction<
      int Function(ffi.Pointer<OpusEncoder>, ffi.Pointer<opus_int32>, int,
          ffi.Pointer<ffi.UnsignedChar>, int)>();

  /// Encodes an Opus frame from floating point input.
  /// @param [in] st <tt>OpusEncoder*</tt>: Encoder state
  /// @param [in] pcm <tt>float*</tt>: Input in float format (interleaved if 2 channels), with a normal range of +/-1.0.
  /// Samples with a range beyond +/-1.0 are supported but will
  /// be clipped by decoders using the integer API and should
  /// only be used if it is known that the far end supports
  /// extended dynamic range.
  /// length is frame_size*channels*sizeof(float)
  /// @param [in] frame_size <tt>int</tt>: Number of samples per channel in the
  /// input signal.
  /// This must be an Opus frame size for
  /// the encoder's sampling rate.
  /// For example, at 48 kHz the permitted
  /// values are 120, 240, 480, 960, 1920,
  /// and 2880.
  /// Passing in a duration of less than
  /// 10 ms (480 samples at 48 kHz) will
  /// prevent the encoder from using the LPC
  /// or hybrid modes.
  /// @param [out] data <tt>unsigned char*</tt>: Output payload.
  /// This must contain storage for at
  /// least \a max_data_bytes.
  /// @param [in] max_data_bytes <tt>opus_int32</tt>: Size of the allocated
  /// memory for the output
  /// payload. This may be
  /// used to impose an upper limit on
  /// the instant bitrate, but should
  /// not be used as the only bitrate
  /// control. Use #OPUS_SET_BITRATE to
  /// control the bitrate.
  /// @returns The length of the encoded packet (in bytes) on success or a
  /// negative error code (see @ref opus_errorcodes) on failure.
  int opus_encode_float(
    ffi.Pointer<OpusEncoder> st,
    ffi.Pointer<ffi.Float> pcm,
    int frame_size,
    ffi.Pointer<ffi.UnsignedChar> data,
    int max_data_bytes,
  ) {
    return _opus_encode_float(
      st,
      pcm,
      frame_size,
      data,
      max_data_bytes,
    );
  }

  late final _opus_encode_floatPtr = _lookup<
      ffi.NativeFunction<
          opus_int32 Function(
              ffi.Pointer<OpusEncoder>,
              ffi.Pointer<ffi.Float>,
              ffi.Int,
              ffi.Pointer<ffi.UnsignedChar>,
              opus_int32)>>('opus_encode_float');
  late final _opus_encode_float = _opus_encode_floatPtr.asFunction<
      int Function(ffi.Pointer<OpusEncoder>, ffi.Pointer<ffi.Float>, int,
          ffi.Pointer<ffi.UnsignedChar>, int)>();

  /// Frees an <code>OpusEncoder</code> allocated by opus_encoder_create().
  /// @param[in] st <tt>OpusEncoder*</tt>: State to be freed.
  void opus_encoder_destroy(
    ffi.Pointer<OpusEncoder> st,
  ) {
    return _opus_encoder_destroy(
      st,
    );
  }

  late final _opus_encoder_destroyPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<OpusEncoder>)>>(
          'opus_encoder_destroy');
  late final _opus_encoder_destroy = _opus_encoder_destroyPtr
      .asFunction<void Function(ffi.Pointer<OpusEncoder>)>();

  /// Perform a CTL function on an Opus encoder.
  ///
  /// Generally the request and subsequent arguments are generated
  /// by a convenience macro.
  /// @param st <tt>OpusEncoder*</tt>: Encoder state.
  /// @param request This and all remaining parameters should be replaced by one
  /// of the convenience macros in @ref opus_genericctls or
  /// @ref opus_encoderctls.
  /// @see opus_genericctls
  /// @see opus_encoderctls
  int opus_encoder_ctl(
    ffi.Pointer<OpusEncoder> st,
    int request,
  ) {
    return _opus_encoder_ctl(
      st,
      request,
    );
  }

  ///这个函数对应的C函数是个可变函数,ffigen无法生成,手动添加一个
  /// Perform a CTL function on an Opus encoder.
  ///
  /// Generally the request and subsequent arguments are generated
  /// by a convenience macro.
  /// @param st <tt>OpusEncoder*</tt>: Encoder state.
  /// @param request This and all remaining parameters should be replaced by one
  /// of the convenience macros in @ref opus_genericctls or
  /// @ref opus_encoderctls.
  /// @see opus_genericctls
  /// @see opus_encoderctls
  int opus_encoder_ctl_int(
    ffi.Pointer<OpusEncoder> st,
    int request,
    int value,
  ) {
    return _opus_encoder_ctl_int(st, request, value);
  }

  late final _opus_encoder_ctlPtr_int = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<OpusEncoder>, ffi.Int, ffi.Int)>>('opus_encoder_ctl');
  late final _opus_encoder_ctl_int = _opus_encoder_ctlPtr_int
      .asFunction<int Function(ffi.Pointer<OpusEncoder>, int, int)>();

  late final _opus_encoder_ctlPtr = _lookup<
          ffi
          .NativeFunction<ffi.Int Function(ffi.Pointer<OpusEncoder>, ffi.Int)>>(
      'opus_encoder_ctl');
  late final _opus_encoder_ctl = _opus_encoder_ctlPtr
      .asFunction<int Function(ffi.Pointer<OpusEncoder>, int)>();

  /// Gets the size of an <code>OpusDecoder</code> structure.
  /// @param [in] channels <tt>int</tt>: Number of channels.
  /// This must be 1 or 2.
  /// @returns The size in bytes.
  int opus_decoder_get_size(
    int channels,
  ) {
    return _opus_decoder_get_size(
      channels,
    );
  }

  late final _opus_decoder_get_sizePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          'opus_decoder_get_size');
  late final _opus_decoder_get_size =
      _opus_decoder_get_sizePtr.asFunction<int Function(int)>();

  /// Allocates and initializes a decoder state.
  /// @param [in] Fs <tt>opus_int32</tt>: Sample rate to decode at (Hz).
  /// This must be one of 8000, 12000, 16000,
  /// 24000, or 48000.
  /// @param [in] channels <tt>int</tt>: Number of channels (1 or 2) to decode
  /// @param [out] error <tt>int*</tt>: #OPUS_OK Success or @ref opus_errorcodes
  ///
  /// Internally Opus stores data at 48000 Hz, so that should be the default
  /// value for Fs. However, the decoder can efficiently decode to buffers
  /// at 8, 12, 16, and 24 kHz so if for some reason the caller cannot use
  /// data at the full sample rate, or knows the compressed data doesn't
  /// use the full frequency range, it can request decoding at a reduced
  /// rate. Likewise, the decoder is capable of filling in either mono or
  /// interleaved stereo pcm buffers, at the caller's request.
  ffi.Pointer<OpusDecoder> opus_decoder_create(
    int Fs,
    int channels,
    ffi.Pointer<ffi.Int> error,
  ) {
    return _opus_decoder_create(
      Fs,
      channels,
      error,
    );
  }

  late final _opus_decoder_createPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OpusDecoder> Function(opus_int32, ffi.Int,
              ffi.Pointer<ffi.Int>)>>('opus_decoder_create');
  late final _opus_decoder_create = _opus_decoder_createPtr.asFunction<
      ffi.Pointer<OpusDecoder> Function(int, int, ffi.Pointer<ffi.Int>)>();

  /// Initializes a previously allocated decoder state.
  /// The state must be at least the size returned by opus_decoder_get_size().
  /// This is intended for applications which use their own allocator instead of malloc. @see opus_decoder_create,opus_decoder_get_size
  /// To reset a previously initialized state, use the #OPUS_RESET_STATE CTL.
  /// @param [in] st <tt>OpusDecoder*</tt>: Decoder state.
  /// @param [in] Fs <tt>opus_int32</tt>: Sampling rate to decode to (Hz).
  /// This must be one of 8000, 12000, 16000,
  /// 24000, or 48000.
  /// @param [in] channels <tt>int</tt>: Number of channels (1 or 2) to decode
  /// @retval #OPUS_OK Success or @ref opus_errorcodes
  int opus_decoder_init(
    ffi.Pointer<OpusDecoder> st,
    int Fs,
    int channels,
  ) {
    return _opus_decoder_init(
      st,
      Fs,
      channels,
    );
  }

  late final _opus_decoder_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<OpusDecoder>, opus_int32,
              ffi.Int)>>('opus_decoder_init');
  late final _opus_decoder_init = _opus_decoder_initPtr
      .asFunction<int Function(ffi.Pointer<OpusDecoder>, int, int)>();

  /// Decode an Opus packet.
  /// @param [in] st <tt>OpusDecoder*</tt>: Decoder state
  /// @param [in] data <tt>char*</tt>: Input payload. Use a NULL pointer to indicate packet loss
  /// @param [in] len <tt>opus_int32</tt>: Number of bytes in payload*
  /// @param [out] pcm <tt>opus_int16*</tt>: Output signal (interleaved if 2 channels). length
  /// is frame_size*channels*sizeof(opus_int16)
  /// @param [in] frame_size Number of samples per channel of available space in \a pcm.
  /// If this is less than the maximum packet duration (120ms; 5760 for 48kHz), this function will
  /// not be capable of decoding some packets. In the case of PLC (data==NULL) or FEC (decode_fec=1),
  /// then frame_size needs to be exactly the duration of audio that is missing, otherwise the
  /// decoder will not be in the optimal state to decode the next incoming packet. For the PLC and
  /// FEC cases, frame_size <b>must</b> be a multiple of 2.5 ms.
  /// @param [in] decode_fec <tt>int</tt>: Flag (0 or 1) to request that any in-band forward error correction data be
  /// decoded. If no such data is available, the frame is decoded as if it were lost.
  /// @returns Number of decoded samples or @ref opus_errorcodes
  int opus_decode(
    ffi.Pointer<OpusDecoder> st,
    ffi.Pointer<ffi.UnsignedChar> data,
    int len,
    ffi.Pointer<opus_int16> pcm,
    int frame_size,
    int decode_fec,
  ) {
    return _opus_decode(
      st,
      data,
      len,
      pcm,
      frame_size,
      decode_fec,
    );
  }

  late final _opus_decodePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<OpusDecoder>,
              ffi.Pointer<ffi.UnsignedChar>,
              opus_int32,
              ffi.Pointer<opus_int16>,
              ffi.Int,
              ffi.Int)>>('opus_decode');
  late final _opus_decode = _opus_decodePtr.asFunction<
      int Function(ffi.Pointer<OpusDecoder>, ffi.Pointer<ffi.UnsignedChar>, int,
          ffi.Pointer<opus_int16>, int, int)>();

  /// Decode an Opus packet.
  /// @param [in] st <tt>OpusDecoder*</tt>: Decoder state
  /// @param [in] data <tt>char*</tt>: Input payload. Use a NULL pointer to indicate packet loss
  /// @param [in] len <tt>opus_int32</tt>: Number of bytes in payload*
  /// @param [out] pcm <tt>opus_int32*</tt>: Output signal (interleaved if 2 channels) representing (or slightly exceeding) 24-bit values. length
  /// is frame_size*channels*sizeof(opus_int32)
  /// @param [in] frame_size Number of samples per channel of available space in \a pcm.
  /// If this is less than the maximum packet duration (120ms; 5760 for 48kHz), this function will
  /// not be capable of decoding some packets. In the case of PLC (data==NULL) or FEC (decode_fec=1),
  /// then frame_size needs to be exactly the duration of audio that is missing, otherwise the
  /// decoder will not be in the optimal state to decode the next incoming packet. For the PLC and
  /// FEC cases, frame_size <b>must</b> be a multiple of 2.5 ms.
  /// @param [in] decode_fec <tt>int</tt>: Flag (0 or 1) to request that any in-band forward error correction data be
  /// decoded. If no such data is available, the frame is decoded as if it were lost.
  /// @returns Number of decoded samples or @ref opus_errorcodes
  int opus_decode24(
    ffi.Pointer<OpusDecoder> st,
    ffi.Pointer<ffi.UnsignedChar> data,
    int len,
    ffi.Pointer<opus_int32> pcm,
    int frame_size,
    int decode_fec,
  ) {
    return _opus_decode24(
      st,
      data,
      len,
      pcm,
      frame_size,
      decode_fec,
    );
  }

  late final _opus_decode24Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<OpusDecoder>,
              ffi.Pointer<ffi.UnsignedChar>,
              opus_int32,
              ffi.Pointer<opus_int32>,
              ffi.Int,
              ffi.Int)>>('opus_decode24');
  late final _opus_decode24 = _opus_decode24Ptr.asFunction<
      int Function(ffi.Pointer<OpusDecoder>, ffi.Pointer<ffi.UnsignedChar>, int,
          ffi.Pointer<opus_int32>, int, int)>();

  /// Decode an Opus packet with floating point output.
  /// @param [in] st <tt>OpusDecoder*</tt>: Decoder state
  /// @param [in] data <tt>char*</tt>: Input payload. Use a NULL pointer to indicate packet loss
  /// @param [in] len <tt>opus_int32</tt>: Number of bytes in payload
  /// @param [out] pcm <tt>float*</tt>: Output signal (interleaved if 2 channels). length
  /// is frame_size*channels*sizeof(float)
  /// @param [in] frame_size Number of samples per channel of available space in \a pcm.
  /// If this is less than the maximum packet duration (120ms; 5760 for 48kHz), this function will
  /// not be capable of decoding some packets. In the case of PLC (data==NULL) or FEC (decode_fec=1),
  /// then frame_size needs to be exactly the duration of audio that is missing, otherwise the
  /// decoder will not be in the optimal state to decode the next incoming packet. For the PLC and
  /// FEC cases, frame_size <b>must</b> be a multiple of 2.5 ms.
  /// @param [in] decode_fec <tt>int</tt>: Flag (0 or 1) to request that any in-band forward error correction data be
  /// decoded. If no such data is available the frame is decoded as if it were lost.
  /// @returns Number of decoded samples or @ref opus_errorcodes
  int opus_decode_float(
    ffi.Pointer<OpusDecoder> st,
    ffi.Pointer<ffi.UnsignedChar> data,
    int len,
    ffi.Pointer<ffi.Float> pcm,
    int frame_size,
    int decode_fec,
  ) {
    return _opus_decode_float(
      st,
      data,
      len,
      pcm,
      frame_size,
      decode_fec,
    );
  }

  late final _opus_decode_floatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<OpusDecoder>,
              ffi.Pointer<ffi.UnsignedChar>,
              opus_int32,
              ffi.Pointer<ffi.Float>,
              ffi.Int,
              ffi.Int)>>('opus_decode_float');
  late final _opus_decode_float = _opus_decode_floatPtr.asFunction<
      int Function(ffi.Pointer<OpusDecoder>, ffi.Pointer<ffi.UnsignedChar>, int,
          ffi.Pointer<ffi.Float>, int, int)>();

  /// Perform a CTL function on an Opus decoder.
  ///
  /// Generally the request and subsequent arguments are generated
  /// by a convenience macro.
  /// @param st <tt>OpusDecoder*</tt>: Decoder state.
  /// @param request This and all remaining parameters should be replaced by one
  /// of the convenience macros in @ref opus_genericctls or
  /// @ref opus_decoderctls.
  /// @see opus_genericctls
  /// @see opus_decoderctls
  int opus_decoder_ctl(
    ffi.Pointer<OpusDecoder> st,
    int request,
  ) {
    return _opus_decoder_ctl(
      st,
      request,
    );
  }

  late final _opus_decoder_ctlPtr = _lookup<
          ffi
          .NativeFunction<ffi.Int Function(ffi.Pointer<OpusDecoder>, ffi.Int)>>(
      'opus_decoder_ctl');
  late final _opus_decoder_ctl = _opus_decoder_ctlPtr
      .asFunction<int Function(ffi.Pointer<OpusDecoder>, int)>();

  /// Frees an <code>OpusDecoder</code> allocated by opus_decoder_create().
  /// @param[in] st <tt>OpusDecoder*</tt>: State to be freed.
  void opus_decoder_destroy(
    ffi.Pointer<OpusDecoder> st,
  ) {
    return _opus_decoder_destroy(
      st,
    );
  }

  late final _opus_decoder_destroyPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<OpusDecoder>)>>(
          'opus_decoder_destroy');
  late final _opus_decoder_destroy = _opus_decoder_destroyPtr
      .asFunction<void Function(ffi.Pointer<OpusDecoder>)>();

  /// Gets the size of an <code>OpusDREDDecoder</code> structure.
  /// @returns The size in bytes.
  int opus_dred_decoder_get_size() {
    return _opus_dred_decoder_get_size();
  }

  late final _opus_dred_decoder_get_sizePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>(
          'opus_dred_decoder_get_size');
  late final _opus_dred_decoder_get_size =
      _opus_dred_decoder_get_sizePtr.asFunction<int Function()>();

  /// Allocates and initializes an OpusDREDDecoder state.
  /// @param [out] error <tt>int*</tt>: #OPUS_OK Success or @ref opus_errorcodes
  ffi.Pointer<OpusDREDDecoder> opus_dred_decoder_create(
    ffi.Pointer<ffi.Int> error,
  ) {
    return _opus_dred_decoder_create(
      error,
    );
  }

  late final _opus_dred_decoder_createPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OpusDREDDecoder> Function(
              ffi.Pointer<ffi.Int>)>>('opus_dred_decoder_create');
  late final _opus_dred_decoder_create =
      _opus_dred_decoder_createPtr.asFunction<
          ffi.Pointer<OpusDREDDecoder> Function(ffi.Pointer<ffi.Int>)>();

  /// Initializes an <code>OpusDREDDecoder</code> state.
  /// @param[in] dec <tt>OpusDREDDecoder*</tt>: State to be initialized.
  int opus_dred_decoder_init(
    ffi.Pointer<OpusDREDDecoder> dec,
  ) {
    return _opus_dred_decoder_init(
      dec,
    );
  }

  late final _opus_dred_decoder_initPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<OpusDREDDecoder>)>>(
      'opus_dred_decoder_init');
  late final _opus_dred_decoder_init = _opus_dred_decoder_initPtr
      .asFunction<int Function(ffi.Pointer<OpusDREDDecoder>)>();

  /// Frees an <code>OpusDREDDecoder</code> allocated by opus_dred_decoder_create().
  /// @param[in] dec <tt>OpusDREDDecoder*</tt>: State to be freed.
  void opus_dred_decoder_destroy(
    ffi.Pointer<OpusDREDDecoder> dec,
  ) {
    return _opus_dred_decoder_destroy(
      dec,
    );
  }

  late final _opus_dred_decoder_destroyPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<OpusDREDDecoder>)>>(
      'opus_dred_decoder_destroy');
  late final _opus_dred_decoder_destroy = _opus_dred_decoder_destroyPtr
      .asFunction<void Function(ffi.Pointer<OpusDREDDecoder>)>();

  /// Perform a CTL function on an Opus DRED decoder.
  ///
  /// Generally the request and subsequent arguments are generated
  /// by a convenience macro.
  /// @param dred_dec <tt>OpusDREDDecoder*</tt>: DRED Decoder state.
  /// @param request This and all remaining parameters should be replaced by one
  /// of the convenience macros in @ref opus_genericctls or
  /// @ref opus_decoderctls.
  /// @see opus_genericctls
  /// @see opus_decoderctls
  int opus_dred_decoder_ctl(
    ffi.Pointer<OpusDREDDecoder> dred_dec,
    int request,
  ) {
    return _opus_dred_decoder_ctl(
      dred_dec,
      request,
    );
  }

  late final _opus_dred_decoder_ctlPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<OpusDREDDecoder>, ffi.Int)>>('opus_dred_decoder_ctl');
  late final _opus_dred_decoder_ctl = _opus_dred_decoder_ctlPtr
      .asFunction<int Function(ffi.Pointer<OpusDREDDecoder>, int)>();

  /// Gets the size of an <code>OpusDRED</code> structure.
  /// @returns The size in bytes.
  int opus_dred_get_size() {
    return _opus_dred_get_size();
  }

  late final _opus_dred_get_sizePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('opus_dred_get_size');
  late final _opus_dred_get_size =
      _opus_dred_get_sizePtr.asFunction<int Function()>();

  /// Allocates and initializes a DRED state.
  /// @param [out] error <tt>int*</tt>: #OPUS_OK Success or @ref opus_errorcodes
  ffi.Pointer<OpusDRED> opus_dred_alloc(
    ffi.Pointer<ffi.Int> error,
  ) {
    return _opus_dred_alloc(
      error,
    );
  }

  late final _opus_dred_allocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OpusDRED> Function(
              ffi.Pointer<ffi.Int>)>>('opus_dred_alloc');
  late final _opus_dred_alloc = _opus_dred_allocPtr
      .asFunction<ffi.Pointer<OpusDRED> Function(ffi.Pointer<ffi.Int>)>();

  /// Frees an <code>OpusDRED</code> allocated by opus_dred_create().
  /// @param[in] dec <tt>OpusDRED*</tt>: State to be freed.
  void opus_dred_free(
    ffi.Pointer<OpusDRED> dec,
  ) {
    return _opus_dred_free(
      dec,
    );
  }

  late final _opus_dred_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<OpusDRED>)>>(
          'opus_dred_free');
  late final _opus_dred_free =
      _opus_dred_freePtr.asFunction<void Function(ffi.Pointer<OpusDRED>)>();

  /// Decode an Opus DRED packet.
  /// @param [in] dred_dec <tt>OpusDRED*</tt>: DRED Decoder state
  /// @param [in] dred <tt>OpusDRED*</tt>: DRED state
  /// @param [in] data <tt>char*</tt>: Input payload
  /// @param [in] len <tt>opus_int32</tt>: Number of bytes in payload
  /// @param [in] max_dred_samples <tt>opus_int32</tt>: Maximum number of DRED samples that may be needed (if available in the packet).
  /// @param [in] sampling_rate <tt>opus_int32</tt>: Sampling rate used for max_dred_samples argument. Needs not match the actual sampling rate of the decoder.
  /// @param [out] dred_end <tt>opus_int32*</tt>: Number of non-encoded (silence) samples between the DRED timestamp and the last DRED sample.
  /// @param [in] defer_processing <tt>int</tt>: Flag (0 or 1). If set to one, the CPU-intensive part of the DRED decoding is deferred until opus_dred_process() is called.
  /// @returns Offset (positive) of the first decoded DRED samples, zero if no DRED is present, or @ref opus_errorcodes
  int opus_dred_parse(
    ffi.Pointer<OpusDREDDecoder> dred_dec,
    ffi.Pointer<OpusDRED> dred,
    ffi.Pointer<ffi.UnsignedChar> data,
    int len,
    int max_dred_samples,
    int sampling_rate,
    ffi.Pointer<ffi.Int> dred_end,
    int defer_processing,
  ) {
    return _opus_dred_parse(
      dred_dec,
      dred,
      data,
      len,
      max_dred_samples,
      sampling_rate,
      dred_end,
      defer_processing,
    );
  }

  late final _opus_dred_parsePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<OpusDREDDecoder>,
              ffi.Pointer<OpusDRED>,
              ffi.Pointer<ffi.UnsignedChar>,
              opus_int32,
              opus_int32,
              opus_int32,
              ffi.Pointer<ffi.Int>,
              ffi.Int)>>('opus_dred_parse');
  late final _opus_dred_parse = _opus_dred_parsePtr.asFunction<
      int Function(
          ffi.Pointer<OpusDREDDecoder>,
          ffi.Pointer<OpusDRED>,
          ffi.Pointer<ffi.UnsignedChar>,
          int,
          int,
          int,
          ffi.Pointer<ffi.Int>,
          int)>();

  /// Finish decoding an Opus DRED packet. The function only needs to be called if opus_dred_parse() was called with defer_processing=1.
  /// The source and destination will often be the same DRED state.
  /// @param [in] dred_dec <tt>OpusDRED*</tt>: DRED Decoder state
  /// @param [in] src <tt>OpusDRED*</tt>: Source DRED state to start the processing from.
  /// @param [out] dst <tt>OpusDRED*</tt>: Destination DRED state to store the updated state after processing.
  /// @returns @ref opus_errorcodes
  int opus_dred_process(
    ffi.Pointer<OpusDREDDecoder> dred_dec,
    ffi.Pointer<OpusDRED> src,
    ffi.Pointer<OpusDRED> dst,
  ) {
    return _opus_dred_process(
      dred_dec,
      src,
      dst,
    );
  }

  late final _opus_dred_processPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<OpusDREDDecoder>, ffi.Pointer<OpusDRED>,
              ffi.Pointer<OpusDRED>)>>('opus_dred_process');
  late final _opus_dred_process = _opus_dred_processPtr.asFunction<
      int Function(ffi.Pointer<OpusDREDDecoder>, ffi.Pointer<OpusDRED>,
          ffi.Pointer<OpusDRED>)>();

  /// Decode audio from an Opus DRED packet with 16-bit output.
  /// @param [in] st <tt>OpusDecoder*</tt>: Decoder state
  /// @param [in] dred <tt>OpusDRED*</tt>: DRED state
  /// @param [in] dred_offset <tt>opus_int32</tt>: position of the redundancy to decode (in samples before the beginning of the real audio data in the packet).
  /// @param [out] pcm <tt>opus_int16*</tt>: Output signal (interleaved if 2 channels). length
  /// is frame_size*channels*sizeof(opus_int16)
  /// @param [in] frame_size Number of samples per channel to decode in \a pcm.
  /// frame_size <b>must</b> be a multiple of 2.5 ms.
  /// @returns Number of decoded samples or @ref opus_errorcodes
  int opus_decoder_dred_decode(
    ffi.Pointer<OpusDecoder> st,
    ffi.Pointer<OpusDRED> dred,
    int dred_offset,
    ffi.Pointer<opus_int16> pcm,
    int frame_size,
  ) {
    return _opus_decoder_dred_decode(
      st,
      dred,
      dred_offset,
      pcm,
      frame_size,
    );
  }

  late final _opus_decoder_dred_decodePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<OpusDecoder>,
              ffi.Pointer<OpusDRED>,
              opus_int32,
              ffi.Pointer<opus_int16>,
              opus_int32)>>('opus_decoder_dred_decode');
  late final _opus_decoder_dred_decode =
      _opus_decoder_dred_decodePtr.asFunction<
          int Function(ffi.Pointer<OpusDecoder>, ffi.Pointer<OpusDRED>, int,
              ffi.Pointer<opus_int16>, int)>();

  /// Decode audio from an Opus DRED packet with 24-bit output.
  /// @param [in] st <tt>OpusDecoder*</tt>: Decoder state
  /// @param [in] dred <tt>OpusDRED*</tt>: DRED state
  /// @param [in] dred_offset <tt>opus_int32</tt>: position of the redundancy to decode (in samples before the beginning of the real audio data in the packet).
  /// @param [out] pcm <tt>opus_int32*</tt>: Output signal (interleaved if 2 channels). length
  /// is frame_size*channels*sizeof(opus_int16)
  /// @param [in] frame_size Number of samples per channel to decode in \a pcm.
  /// frame_size <b>must</b> be a multiple of 2.5 ms.
  /// @returns Number of decoded samples or @ref opus_errorcodes
  int opus_decoder_dred_decode24(
    ffi.Pointer<OpusDecoder> st,
    ffi.Pointer<OpusDRED> dred,
    int dred_offset,
    ffi.Pointer<opus_int32> pcm,
    int frame_size,
  ) {
    return _opus_decoder_dred_decode24(
      st,
      dred,
      dred_offset,
      pcm,
      frame_size,
    );
  }

  late final _opus_decoder_dred_decode24Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<OpusDecoder>,
              ffi.Pointer<OpusDRED>,
              opus_int32,
              ffi.Pointer<opus_int32>,
              opus_int32)>>('opus_decoder_dred_decode24');
  late final _opus_decoder_dred_decode24 =
      _opus_decoder_dred_decode24Ptr.asFunction<
          int Function(ffi.Pointer<OpusDecoder>, ffi.Pointer<OpusDRED>, int,
              ffi.Pointer<opus_int32>, int)>();

  /// Decode audio from an Opus DRED packet with floating point output.
  /// @param [in] st <tt>OpusDecoder*</tt>: Decoder state
  /// @param [in] dred <tt>OpusDRED*</tt>: DRED state
  /// @param [in] dred_offset <tt>opus_int32</tt>: position of the redundancy to decode (in samples before the beginning of the real audio data in the packet).
  /// @param [out] pcm <tt>float*</tt>: Output signal (interleaved if 2 channels). length
  /// is frame_size*channels*sizeof(float)
  /// @param [in] frame_size Number of samples per channel to decode in \a pcm.
  /// frame_size <b>must</b> be a multiple of 2.5 ms.
  /// @returns Number of decoded samples or @ref opus_errorcodes
  int opus_decoder_dred_decode_float(
    ffi.Pointer<OpusDecoder> st,
    ffi.Pointer<OpusDRED> dred,
    int dred_offset,
    ffi.Pointer<ffi.Float> pcm,
    int frame_size,
  ) {
    return _opus_decoder_dred_decode_float(
      st,
      dred,
      dred_offset,
      pcm,
      frame_size,
    );
  }

  late final _opus_decoder_dred_decode_floatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<OpusDecoder>,
              ffi.Pointer<OpusDRED>,
              opus_int32,
              ffi.Pointer<ffi.Float>,
              opus_int32)>>('opus_decoder_dred_decode_float');
  late final _opus_decoder_dred_decode_float =
      _opus_decoder_dred_decode_floatPtr.asFunction<
          int Function(ffi.Pointer<OpusDecoder>, ffi.Pointer<OpusDRED>, int,
              ffi.Pointer<ffi.Float>, int)>();

  /// Parse an opus packet into one or more frames.
  /// Opus_decode will perform this operation internally so most applications do
  /// not need to use this function.
  /// This function does not copy the frames, the returned pointers are pointers into
  /// the input packet.
  /// @param [in] data <tt>char*</tt>: Opus packet to be parsed
  /// @param [in] len <tt>opus_int32</tt>: size of data
  /// @param [out] out_toc <tt>char*</tt>: TOC pointer
  /// @param [out] frames <tt>char*[48]</tt> encapsulated frames
  /// @param [out] size <tt>opus_int16[48]</tt> sizes of the encapsulated frames
  /// @param [out] payload_offset <tt>int*</tt>: returns the position of the payload within the packet (in bytes)
  /// @returns number of frames
  int opus_packet_parse(
    ffi.Pointer<ffi.UnsignedChar> data,
    int len,
    ffi.Pointer<ffi.UnsignedChar> out_toc,
    ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>> frames,
    ffi.Pointer<opus_int16> size,
    ffi.Pointer<ffi.Int> payload_offset,
  ) {
    return _opus_packet_parse(
      data,
      len,
      out_toc,
      frames,
      size,
      payload_offset,
    );
  }

  late final _opus_packet_parsePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.UnsignedChar>,
              opus_int32,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
              ffi.Pointer<opus_int16>,
              ffi.Pointer<ffi.Int>)>>('opus_packet_parse');
  late final _opus_packet_parse = _opus_packet_parsePtr.asFunction<
      int Function(
          ffi.Pointer<ffi.UnsignedChar>,
          int,
          ffi.Pointer<ffi.UnsignedChar>,
          ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
          ffi.Pointer<opus_int16>,
          ffi.Pointer<ffi.Int>)>();

  /// Gets the bandwidth of an Opus packet.
  /// @param [in] data <tt>char*</tt>: Opus packet
  /// @retval OPUS_BANDWIDTH_NARROWBAND Narrowband (4kHz bandpass)
  /// @retval OPUS_BANDWIDTH_MEDIUMBAND Mediumband (6kHz bandpass)
  /// @retval OPUS_BANDWIDTH_WIDEBAND Wideband (8kHz bandpass)
  /// @retval OPUS_BANDWIDTH_SUPERWIDEBAND Superwideband (12kHz bandpass)
  /// @retval OPUS_BANDWIDTH_FULLBAND Fullband (20kHz bandpass)
  /// @retval OPUS_INVALID_PACKET The compressed data passed is corrupted or of an unsupported type
  int opus_packet_get_bandwidth(
    ffi.Pointer<ffi.UnsignedChar> data,
  ) {
    return _opus_packet_get_bandwidth(
      data,
    );
  }

  late final _opus_packet_get_bandwidthPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.UnsignedChar>)>>(
      'opus_packet_get_bandwidth');
  late final _opus_packet_get_bandwidth = _opus_packet_get_bandwidthPtr
      .asFunction<int Function(ffi.Pointer<ffi.UnsignedChar>)>();

  /// Gets the number of samples per frame from an Opus packet.
  /// @param [in] data <tt>char*</tt>: Opus packet.
  /// This must contain at least one byte of
  /// data.
  /// @param [in] Fs <tt>opus_int32</tt>: Sampling rate in Hz.
  /// This must be a multiple of 400, or
  /// inaccurate results will be returned.
  /// @returns Number of samples per frame.
  int opus_packet_get_samples_per_frame(
    ffi.Pointer<ffi.UnsignedChar> data,
    int Fs,
  ) {
    return _opus_packet_get_samples_per_frame(
      data,
      Fs,
    );
  }

  late final _opus_packet_get_samples_per_framePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.UnsignedChar>,
              opus_int32)>>('opus_packet_get_samples_per_frame');
  late final _opus_packet_get_samples_per_frame =
      _opus_packet_get_samples_per_framePtr
          .asFunction<int Function(ffi.Pointer<ffi.UnsignedChar>, int)>();

  /// Gets the number of channels from an Opus packet.
  /// @param [in] data <tt>char*</tt>: Opus packet
  /// @returns Number of channels
  /// @retval OPUS_INVALID_PACKET The compressed data passed is corrupted or of an unsupported type
  int opus_packet_get_nb_channels(
    ffi.Pointer<ffi.UnsignedChar> data,
  ) {
    return _opus_packet_get_nb_channels(
      data,
    );
  }

  late final _opus_packet_get_nb_channelsPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.UnsignedChar>)>>(
      'opus_packet_get_nb_channels');
  late final _opus_packet_get_nb_channels = _opus_packet_get_nb_channelsPtr
      .asFunction<int Function(ffi.Pointer<ffi.UnsignedChar>)>();

  /// Gets the number of frames in an Opus packet.
  /// @param [in] packet <tt>char*</tt>: Opus packet
  /// @param [in] len <tt>opus_int32</tt>: Length of packet
  /// @returns Number of frames
  /// @retval OPUS_BAD_ARG Insufficient data was passed to the function
  /// @retval OPUS_INVALID_PACKET The compressed data passed is corrupted or of an unsupported type
  int opus_packet_get_nb_frames(
    ffi.Pointer<ffi.UnsignedChar> packet,
    int len,
  ) {
    return _opus_packet_get_nb_frames(
      packet,
      len,
    );
  }

  late final _opus_packet_get_nb_framesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.UnsignedChar>,
              opus_int32)>>('opus_packet_get_nb_frames');
  late final _opus_packet_get_nb_frames = _opus_packet_get_nb_framesPtr
      .asFunction<int Function(ffi.Pointer<ffi.UnsignedChar>, int)>();

  /// Gets the number of samples of an Opus packet.
  /// @param [in] packet <tt>char*</tt>: Opus packet
  /// @param [in] len <tt>opus_int32</tt>: Length of packet
  /// @param [in] Fs <tt>opus_int32</tt>: Sampling rate in Hz.
  /// This must be a multiple of 400, or
  /// inaccurate results will be returned.
  /// @returns Number of samples
  /// @retval OPUS_BAD_ARG Insufficient data was passed to the function
  /// @retval OPUS_INVALID_PACKET The compressed data passed is corrupted or of an unsupported type
  int opus_packet_get_nb_samples(
    ffi.Pointer<ffi.UnsignedChar> packet,
    int len,
    int Fs,
  ) {
    return _opus_packet_get_nb_samples(
      packet,
      len,
      Fs,
    );
  }

  late final _opus_packet_get_nb_samplesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.UnsignedChar>, opus_int32,
              opus_int32)>>('opus_packet_get_nb_samples');
  late final _opus_packet_get_nb_samples = _opus_packet_get_nb_samplesPtr
      .asFunction<int Function(ffi.Pointer<ffi.UnsignedChar>, int, int)>();

  /// Checks whether an Opus packet has LBRR.
  /// @param [in] packet <tt>char*</tt>: Opus packet
  /// @param [in] len <tt>opus_int32</tt>: Length of packet
  /// @returns 1 is LBRR is present, 0 otherwise
  /// @retval OPUS_INVALID_PACKET The compressed data passed is corrupted or of an unsupported type
  int opus_packet_has_lbrr(
    ffi.Pointer<ffi.UnsignedChar> packet,
    int len,
  ) {
    return _opus_packet_has_lbrr(
      packet,
      len,
    );
  }

  late final _opus_packet_has_lbrrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.UnsignedChar>,
              opus_int32)>>('opus_packet_has_lbrr');
  late final _opus_packet_has_lbrr = _opus_packet_has_lbrrPtr
      .asFunction<int Function(ffi.Pointer<ffi.UnsignedChar>, int)>();

  /// Gets the number of samples of an Opus packet.
  /// @param [in] dec <tt>OpusDecoder*</tt>: Decoder state
  /// @param [in] packet <tt>char*</tt>: Opus packet
  /// @param [in] len <tt>opus_int32</tt>: Length of packet
  /// @returns Number of samples
  /// @retval OPUS_BAD_ARG Insufficient data was passed to the function
  /// @retval OPUS_INVALID_PACKET The compressed data passed is corrupted or of an unsupported type
  int opus_decoder_get_nb_samples(
    ffi.Pointer<OpusDecoder> dec,
    ffi.Pointer<ffi.UnsignedChar> packet,
    int len,
  ) {
    return _opus_decoder_get_nb_samples(
      dec,
      packet,
      len,
    );
  }

  late final _opus_decoder_get_nb_samplesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<OpusDecoder>,
              ffi.Pointer<ffi.UnsignedChar>,
              opus_int32)>>('opus_decoder_get_nb_samples');
  late final _opus_decoder_get_nb_samples =
      _opus_decoder_get_nb_samplesPtr.asFunction<
          int Function(
              ffi.Pointer<OpusDecoder>, ffi.Pointer<ffi.UnsignedChar>, int)>();

  /// Applies soft-clipping to bring a float signal within the [-1,1] range. If
  /// the signal is already in that range, nothing is done. If there are values
  /// outside of [-1,1], then the signal is clipped as smoothly as possible to
  /// both fit in the range and avoid creating excessive distortion in the
  /// process.
  /// @param [in,out] pcm <tt>float*</tt>: Input PCM and modified PCM
  /// @param [in] frame_size <tt>int</tt> Number of samples per channel to process
  /// @param [in] channels <tt>int</tt>: Number of channels
  /// @param [in,out] softclip_mem <tt>float*</tt>: State memory for the soft clipping process (one float per channel, initialized to zero)
  void opus_pcm_soft_clip(
    ffi.Pointer<ffi.Float> pcm,
    int frame_size,
    int channels,
    ffi.Pointer<ffi.Float> softclip_mem,
  ) {
    return _opus_pcm_soft_clip(
      pcm,
      frame_size,
      channels,
      softclip_mem,
    );
  }

  late final _opus_pcm_soft_clipPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Float>, ffi.Int, ffi.Int,
              ffi.Pointer<ffi.Float>)>>('opus_pcm_soft_clip');
  late final _opus_pcm_soft_clip = _opus_pcm_soft_clipPtr.asFunction<
      void Function(
          ffi.Pointer<ffi.Float>, int, int, ffi.Pointer<ffi.Float>)>();

  /// Gets the size of an <code>OpusRepacketizer</code> structure.
  /// @returns The size in bytes.
  int opus_repacketizer_get_size() {
    return _opus_repacketizer_get_size();
  }

  late final _opus_repacketizer_get_sizePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>(
          'opus_repacketizer_get_size');
  late final _opus_repacketizer_get_size =
      _opus_repacketizer_get_sizePtr.asFunction<int Function()>();

  /// (Re)initializes a previously allocated repacketizer state.
  /// The state must be at least the size returned by opus_repacketizer_get_size().
  /// This can be used for applications which use their own allocator instead of
  /// malloc().
  /// It must also be called to reset the queue of packets waiting to be
  /// repacketized, which is necessary if the maximum packet duration of 120 ms
  /// is reached or if you wish to submit packets with a different Opus
  /// configuration (coding mode, audio bandwidth, frame size, or channel count).
  /// Failure to do so will prevent a new packet from being added with
  /// opus_repacketizer_cat().
  /// @see opus_repacketizer_create
  /// @see opus_repacketizer_get_size
  /// @see opus_repacketizer_cat
  /// @param rp <tt>OpusRepacketizer*</tt>: The repacketizer state to
  /// (re)initialize.
  /// @returns A pointer to the same repacketizer state that was passed in.
  ffi.Pointer<OpusRepacketizer> opus_repacketizer_init(
    ffi.Pointer<OpusRepacketizer> rp,
  ) {
    return _opus_repacketizer_init(
      rp,
    );
  }

  late final _opus_repacketizer_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OpusRepacketizer> Function(
              ffi.Pointer<OpusRepacketizer>)>>('opus_repacketizer_init');
  late final _opus_repacketizer_init = _opus_repacketizer_initPtr.asFunction<
      ffi.Pointer<OpusRepacketizer> Function(ffi.Pointer<OpusRepacketizer>)>();

  /// Allocates memory and initializes the new repacketizer with
  /// opus_repacketizer_init().
  ffi.Pointer<OpusRepacketizer> opus_repacketizer_create() {
    return _opus_repacketizer_create();
  }

  late final _opus_repacketizer_createPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<OpusRepacketizer> Function()>>(
          'opus_repacketizer_create');
  late final _opus_repacketizer_create = _opus_repacketizer_createPtr
      .asFunction<ffi.Pointer<OpusRepacketizer> Function()>();

  /// Frees an <code>OpusRepacketizer</code> allocated by
  /// opus_repacketizer_create().
  /// @param[in] rp <tt>OpusRepacketizer*</tt>: State to be freed.
  void opus_repacketizer_destroy(
    ffi.Pointer<OpusRepacketizer> rp,
  ) {
    return _opus_repacketizer_destroy(
      rp,
    );
  }

  late final _opus_repacketizer_destroyPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<OpusRepacketizer>)>>(
      'opus_repacketizer_destroy');
  late final _opus_repacketizer_destroy = _opus_repacketizer_destroyPtr
      .asFunction<void Function(ffi.Pointer<OpusRepacketizer>)>();

  /// Add a packet to the current repacketizer state.
  /// This packet must match the configuration of any packets already submitted
  /// for repacketization since the last call to opus_repacketizer_init().
  /// This means that it must have the same coding mode, audio bandwidth, frame
  /// size, and channel count.
  /// This can be checked in advance by examining the top 6 bits of the first
  /// byte of the packet, and ensuring they match the top 6 bits of the first
  /// byte of any previously submitted packet.
  /// The total duration of audio in the repacketizer state also must not exceed
  /// 120 ms, the maximum duration of a single packet, after adding this packet.
  ///
  /// The contents of the current repacketizer state can be extracted into new
  /// packets using opus_repacketizer_out() or opus_repacketizer_out_range().
  ///
  /// In order to add a packet with a different configuration or to add more
  /// audio beyond 120 ms, you must clear the repacketizer state by calling
  /// opus_repacketizer_init().
  /// If a packet is too large to add to the current repacketizer state, no part
  /// of it is added, even if it contains multiple frames, some of which might
  /// fit.
  /// If you wish to be able to add parts of such packets, you should first use
  /// another repacketizer to split the packet into pieces and add them
  /// individually.
  /// @see opus_repacketizer_out_range
  /// @see opus_repacketizer_out
  /// @see opus_repacketizer_init
  /// @param rp <tt>OpusRepacketizer*</tt>: The repacketizer state to which to
  /// add the packet.
  /// @param[in] data <tt>const unsigned char*</tt>: The packet data.
  /// The application must ensure
  /// this pointer remains valid
  /// until the next call to
  /// opus_repacketizer_init() or
  /// opus_repacketizer_destroy().
  /// @param len <tt>opus_int32</tt>: The number of bytes in the packet data.
  /// @returns An error code indicating whether or not the operation succeeded.
  /// @retval #OPUS_OK The packet's contents have been added to the repacketizer
  /// state.
  /// @retval #OPUS_INVALID_PACKET The packet did not have a valid TOC sequence,
  /// the packet's TOC sequence was not compatible
  /// with previously submitted packets (because
  /// the coding mode, audio bandwidth, frame size,
  /// or channel count did not match), or adding
  /// this packet would increase the total amount of
  /// audio stored in the repacketizer state to more
  /// than 120 ms.
  int opus_repacketizer_cat(
    ffi.Pointer<OpusRepacketizer> rp,
    ffi.Pointer<ffi.UnsignedChar> data,
    int len,
  ) {
    return _opus_repacketizer_cat(
      rp,
      data,
      len,
    );
  }

  late final _opus_repacketizer_catPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<OpusRepacketizer>,
              ffi.Pointer<ffi.UnsignedChar>,
              opus_int32)>>('opus_repacketizer_cat');
  late final _opus_repacketizer_cat = _opus_repacketizer_catPtr.asFunction<
      int Function(
          ffi.Pointer<OpusRepacketizer>, ffi.Pointer<ffi.UnsignedChar>, int)>();

  /// Construct a new packet from data previously submitted to the repacketizer
  /// state via opus_repacketizer_cat().
  /// @param rp <tt>OpusRepacketizer*</tt>: The repacketizer state from which to
  /// construct the new packet.
  /// @param begin <tt>int</tt>: The index of the first frame in the current
  /// repacketizer state to include in the output.
  /// @param end <tt>int</tt>: One past the index of the last frame in the
  /// current repacketizer state to include in the
  /// output.
  /// @param[out] data <tt>const unsigned char*</tt>: The buffer in which to
  /// store the output packet.
  /// @param maxlen <tt>opus_int32</tt>: The maximum number of bytes to store in
  /// the output buffer. In order to guarantee
  /// success, this should be at least
  /// <code>1276</code> for a single frame,
  /// or for multiple frames,
  /// <code>1277*(end-begin)</code>.
  /// However, <code>1*(end-begin)</code> plus
  /// the size of all packet data submitted to
  /// the repacketizer since the last call to
  /// opus_repacketizer_init() or
  /// opus_repacketizer_create() is also
  /// sufficient, and possibly much smaller.
  /// @returns The total size of the output packet on success, or an error code
  /// on failure.
  /// @retval #OPUS_BAD_ARG <code>[begin,end)</code> was an invalid range of
  /// frames (begin < 0, begin >= end, or end >
  /// opus_repacketizer_get_nb_frames()).
  /// @retval #OPUS_BUFFER_TOO_SMALL \a maxlen was insufficient to contain the
  /// complete output packet.
  int opus_repacketizer_out_range(
    ffi.Pointer<OpusRepacketizer> rp,
    int begin,
    int end,
    ffi.Pointer<ffi.UnsignedChar> data,
    int maxlen,
  ) {
    return _opus_repacketizer_out_range(
      rp,
      begin,
      end,
      data,
      maxlen,
    );
  }

  late final _opus_repacketizer_out_rangePtr = _lookup<
      ffi.NativeFunction<
          opus_int32 Function(
              ffi.Pointer<OpusRepacketizer>,
              ffi.Int,
              ffi.Int,
              ffi.Pointer<ffi.UnsignedChar>,
              opus_int32)>>('opus_repacketizer_out_range');
  late final _opus_repacketizer_out_range =
      _opus_repacketizer_out_rangePtr.asFunction<
          int Function(ffi.Pointer<OpusRepacketizer>, int, int,
              ffi.Pointer<ffi.UnsignedChar>, int)>();

  /// Return the total number of frames contained in packet data submitted to
  /// the repacketizer state so far via opus_repacketizer_cat() since the last
  /// call to opus_repacketizer_init() or opus_repacketizer_create().
  /// This defines the valid range of packets that can be extracted with
  /// opus_repacketizer_out_range() or opus_repacketizer_out().
  /// @param rp <tt>OpusRepacketizer*</tt>: The repacketizer state containing the
  /// frames.
  /// @returns The total number of frames contained in the packet data submitted
  /// to the repacketizer state.
  int opus_repacketizer_get_nb_frames(
    ffi.Pointer<OpusRepacketizer> rp,
  ) {
    return _opus_repacketizer_get_nb_frames(
      rp,
    );
  }

  late final _opus_repacketizer_get_nb_framesPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<OpusRepacketizer>)>>(
      'opus_repacketizer_get_nb_frames');
  late final _opus_repacketizer_get_nb_frames =
      _opus_repacketizer_get_nb_framesPtr
          .asFunction<int Function(ffi.Pointer<OpusRepacketizer>)>();

  /// Construct a new packet from data previously submitted to the repacketizer
  /// state via opus_repacketizer_cat().
  /// This is a convenience routine that returns all the data submitted so far
  /// in a single packet.
  /// It is equivalent to calling
  /// @code
  /// opus_repacketizer_out_range(rp, 0, opus_repacketizer_get_nb_frames(rp),
  /// data, maxlen)
  /// @endcode
  /// @param rp <tt>OpusRepacketizer*</tt>: The repacketizer state from which to
  /// construct the new packet.
  /// @param[out] data <tt>const unsigned char*</tt>: The buffer in which to
  /// store the output packet.
  /// @param maxlen <tt>opus_int32</tt>: The maximum number of bytes to store in
  /// the output buffer. In order to guarantee
  /// success, this should be at least
  /// <code>1277*opus_repacketizer_get_nb_frames(rp)</code>.
  /// However,
  /// <code>1*opus_repacketizer_get_nb_frames(rp)</code>
  /// plus the size of all packet data
  /// submitted to the repacketizer since the
  /// last call to opus_repacketizer_init() or
  /// opus_repacketizer_create() is also
  /// sufficient, and possibly much smaller.
  /// @returns The total size of the output packet on success, or an error code
  /// on failure.
  /// @retval #OPUS_BUFFER_TOO_SMALL \a maxlen was insufficient to contain the
  /// complete output packet.
  int opus_repacketizer_out(
    ffi.Pointer<OpusRepacketizer> rp,
    ffi.Pointer<ffi.UnsignedChar> data,
    int maxlen,
  ) {
    return _opus_repacketizer_out(
      rp,
      data,
      maxlen,
    );
  }

  late final _opus_repacketizer_outPtr = _lookup<
      ffi.NativeFunction<
          opus_int32 Function(
              ffi.Pointer<OpusRepacketizer>,
              ffi.Pointer<ffi.UnsignedChar>,
              opus_int32)>>('opus_repacketizer_out');
  late final _opus_repacketizer_out = _opus_repacketizer_outPtr.asFunction<
      int Function(
          ffi.Pointer<OpusRepacketizer>, ffi.Pointer<ffi.UnsignedChar>, int)>();

  /// Pads a given Opus packet to a larger size (possibly changing the TOC sequence).
  /// @param[in,out] data <tt>const unsigned char*</tt>: The buffer containing the
  /// packet to pad.
  /// @param len <tt>opus_int32</tt>: The size of the packet.
  /// This must be at least 1.
  /// @param new_len <tt>opus_int32</tt>: The desired size of the packet after padding.
  /// This must be at least as large as len.
  /// @returns an error code
  /// @retval #OPUS_OK \a on success.
  /// @retval #OPUS_BAD_ARG \a len was less than 1 or new_len was less than len.
  /// @retval #OPUS_INVALID_PACKET \a data did not contain a valid Opus packet.
  int opus_packet_pad(
    ffi.Pointer<ffi.UnsignedChar> data,
    int len,
    int new_len,
  ) {
    return _opus_packet_pad(
      data,
      len,
      new_len,
    );
  }

  late final _opus_packet_padPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.UnsignedChar>, opus_int32,
              opus_int32)>>('opus_packet_pad');
  late final _opus_packet_pad = _opus_packet_padPtr
      .asFunction<int Function(ffi.Pointer<ffi.UnsignedChar>, int, int)>();

  /// Remove all padding from a given Opus packet and rewrite the TOC sequence to
  /// minimize space usage.
  /// @param[in,out] data <tt>const unsigned char*</tt>: The buffer containing the
  /// packet to strip.
  /// @param len <tt>opus_int32</tt>: The size of the packet.
  /// This must be at least 1.
  /// @returns The new size of the output packet on success, or an error code
  /// on failure.
  /// @retval #OPUS_BAD_ARG \a len was less than 1.
  /// @retval #OPUS_INVALID_PACKET \a data did not contain a valid Opus packet.
  int opus_packet_unpad(
    ffi.Pointer<ffi.UnsignedChar> data,
    int len,
  ) {
    return _opus_packet_unpad(
      data,
      len,
    );
  }

  late final _opus_packet_unpadPtr = _lookup<
      ffi.NativeFunction<
          opus_int32 Function(
              ffi.Pointer<ffi.UnsignedChar>, opus_int32)>>('opus_packet_unpad');
  late final _opus_packet_unpad = _opus_packet_unpadPtr
      .asFunction<int Function(ffi.Pointer<ffi.UnsignedChar>, int)>();

  /// Pads a given Opus multi-stream packet to a larger size (possibly changing the TOC sequence).
  /// @param[in,out] data <tt>const unsigned char*</tt>: The buffer containing the
  /// packet to pad.
  /// @param len <tt>opus_int32</tt>: The size of the packet.
  /// This must be at least 1.
  /// @param new_len <tt>opus_int32</tt>: The desired size of the packet after padding.
  /// This must be at least 1.
  /// @param nb_streams <tt>opus_int32</tt>: The number of streams (not channels) in the packet.
  /// This must be at least as large as len.
  /// @returns an error code
  /// @retval #OPUS_OK \a on success.
  /// @retval #OPUS_BAD_ARG \a len was less than 1.
  /// @retval #OPUS_INVALID_PACKET \a data did not contain a valid Opus packet.
  int opus_multistream_packet_pad(
    ffi.Pointer<ffi.UnsignedChar> data,
    int len,
    int new_len,
    int nb_streams,
  ) {
    return _opus_multistream_packet_pad(
      data,
      len,
      new_len,
      nb_streams,
    );
  }

  late final _opus_multistream_packet_padPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.UnsignedChar>, opus_int32,
              opus_int32, ffi.Int)>>('opus_multistream_packet_pad');
  late final _opus_multistream_packet_pad = _opus_multistream_packet_padPtr
      .asFunction<int Function(ffi.Pointer<ffi.UnsignedChar>, int, int, int)>();

  /// Remove all padding from a given Opus multi-stream packet and rewrite the TOC sequence to
  /// minimize space usage.
  /// @param[in,out] data <tt>const unsigned char*</tt>: The buffer containing the
  /// packet to strip.
  /// @param len <tt>opus_int32</tt>: The size of the packet.
  /// This must be at least 1.
  /// @param nb_streams <tt>opus_int32</tt>: The number of streams (not channels) in the packet.
  /// This must be at least 1.
  /// @returns The new size of the output packet on success, or an error code
  /// on failure.
  /// @retval #OPUS_BAD_ARG \a len was less than 1 or new_len was less than len.
  /// @retval #OPUS_INVALID_PACKET \a data did not contain a valid Opus packet.
  int opus_multistream_packet_unpad(
    ffi.Pointer<ffi.UnsignedChar> data,
    int len,
    int nb_streams,
  ) {
    return _opus_multistream_packet_unpad(
      data,
      len,
      nb_streams,
    );
  }

  late final _opus_multistream_packet_unpadPtr = _lookup<
      ffi.NativeFunction<
          opus_int32 Function(ffi.Pointer<ffi.UnsignedChar>, opus_int32,
              ffi.Int)>>('opus_multistream_packet_unpad');
  late final _opus_multistream_packet_unpad = _opus_multistream_packet_unpadPtr
      .asFunction<int Function(ffi.Pointer<ffi.UnsignedChar>, int, int)>();
}

final class OpusEncoder extends ffi.Opaque {}

typedef opus_int32 = ffi.Int32;
typedef Dartopus_int32 = int;
typedef opus_int16 = ffi.Int16;
typedef Dartopus_int16 = int;

final class OpusDecoder extends ffi.Opaque {}

final class OpusDREDDecoder extends ffi.Opaque {}

final class OpusDRED extends ffi.Opaque {}

final class OpusRepacketizer extends ffi.Opaque {}
