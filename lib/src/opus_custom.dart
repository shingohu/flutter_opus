// ignore_for_file: always_specify_types
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

import 'dynamic_library.dart';

/// Bindings for `src/opus/include/opus_custom.h`.
///
/// Regenerate bindings with `dart run ffigen --config ffigen.yaml`.
///
class OpusCustom {
  /// Holds the symbol lookup function.
  ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      get _lookup => dylib.lookup;

  /// Creates a new mode struct. This will be passed to an encoder or
  /// decoder. The mode MUST NOT BE DESTROYED until the encoders and
  /// decoders that use it are destroyed as well.
  /// @param [in] Fs <tt>int</tt>: Sampling rate (8000 to 96000 Hz)
  /// @param [in] frame_size <tt>int</tt>: Number of samples (per channel) to encode in each
  /// packet (64 - 1024, prime factorization must contain zero or more 2s, 3s, or 5s and no other primes)
  /// @param [out] error <tt>int*</tt>: Returned error code (if NULL, no error will be returned)
  /// @return A newly created mode
  ffi.Pointer<OpusCustomMode> opus_custom_mode_create(
    int Fs,
    int frame_size,
    ffi.Pointer<ffi.Int> error,
  ) {
    return _opus_custom_mode_create(
      Fs,
      frame_size,
      error,
    );
  }

  late final _opus_custom_mode_createPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OpusCustomMode> Function(opus_int32, ffi.Int,
              ffi.Pointer<ffi.Int>)>>('opus_custom_mode_create');
  late final _opus_custom_mode_create = _opus_custom_mode_createPtr.asFunction<
      ffi.Pointer<OpusCustomMode> Function(int, int, ffi.Pointer<ffi.Int>)>();

  /// Destroys a mode struct. Only call this after all encoders and
  /// decoders using this mode are destroyed as well.
  /// @param [in] mode <tt>OpusCustomMode*</tt>: Mode to be freed.
  void opus_custom_mode_destroy(
    ffi.Pointer<OpusCustomMode> mode,
  ) {
    return _opus_custom_mode_destroy(
      mode,
    );
  }

  late final _opus_custom_mode_destroyPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<OpusCustomMode>)>>(
      'opus_custom_mode_destroy');
  late final _opus_custom_mode_destroy = _opus_custom_mode_destroyPtr
      .asFunction<void Function(ffi.Pointer<OpusCustomMode>)>();

  /// Encoder */
  /// /** Gets the size of an OpusCustomEncoder structure.
  /// @param [in] mode <tt>OpusCustomMode *</tt>: Mode configuration
  /// @param [in] channels <tt>int</tt>: Number of channels
  /// @returns size
  int opus_custom_encoder_get_size(
    ffi.Pointer<OpusCustomMode> mode,
    int channels,
  ) {
    return _opus_custom_encoder_get_size(
      mode,
      channels,
    );
  }

  late final _opus_custom_encoder_get_sizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<OpusCustomMode>,
              ffi.Int)>>('opus_custom_encoder_get_size');
  late final _opus_custom_encoder_get_size = _opus_custom_encoder_get_sizePtr
      .asFunction<int Function(ffi.Pointer<OpusCustomMode>, int)>();

  /// Creates a new encoder state. Each stream needs its own encoder
  /// state (can't be shared across simultaneous streams).
  /// @param [in] mode <tt>OpusCustomMode*</tt>: Contains all the information about the characteristics of
  /// the stream (must be the same characteristics as used for the
  /// decoder)
  /// @param [in] channels <tt>int</tt>: Number of channels
  /// @param [out] error <tt>int*</tt>: Returns an error code
  /// @return Newly created encoder state.
  ffi.Pointer<OpusCustomEncoder> opus_custom_encoder_create(
    ffi.Pointer<OpusCustomMode> mode,
    int channels,
    ffi.Pointer<ffi.Int> error,
  ) {
    return _opus_custom_encoder_create(
      mode,
      channels,
      error,
    );
  }

  late final _opus_custom_encoder_createPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OpusCustomEncoder> Function(ffi.Pointer<OpusCustomMode>,
              ffi.Int, ffi.Pointer<ffi.Int>)>>('opus_custom_encoder_create');
  late final _opus_custom_encoder_create =
      _opus_custom_encoder_createPtr.asFunction<
          ffi.Pointer<OpusCustomEncoder> Function(
              ffi.Pointer<OpusCustomMode>, int, ffi.Pointer<ffi.Int>)>();

  /// Destroys an encoder state.
  /// @param[in] st <tt>OpusCustomEncoder*</tt>: State to be freed.
  void opus_custom_encoder_destroy(
    ffi.Pointer<OpusCustomEncoder> st,
  ) {
    return _opus_custom_encoder_destroy(
      st,
    );
  }

  late final _opus_custom_encoder_destroyPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<OpusCustomEncoder>)>>(
      'opus_custom_encoder_destroy');
  late final _opus_custom_encoder_destroy = _opus_custom_encoder_destroyPtr
      .asFunction<void Function(ffi.Pointer<OpusCustomEncoder>)>();

  /// Encodes a frame of audio.
  /// @param [in] st <tt>OpusCustomEncoder*</tt>: Encoder state
  /// @param [in] pcm <tt>float*</tt>: PCM audio in float format, with a normal range of +/-1.0.
  /// Samples with a range beyond +/-1.0 are supported but will
  /// be clipped by decoders using the integer API and should
  /// only be used if it is known that the far end supports
  /// extended dynamic range. There must be exactly
  /// frame_size samples per channel.
  /// @param [in] frame_size <tt>int</tt>: Number of samples per frame of input signal
  /// @param [out] compressed <tt>char *</tt>: The compressed data is written here. This may not alias pcm and must be at least maxCompressedBytes long.
  /// @param [in] maxCompressedBytes <tt>int</tt>: Maximum number of bytes to use for compressing the frame
  /// (can change from one frame to another)
  /// @return Number of bytes written to "compressed".
  /// If negative, an error has occurred (see error codes). It is IMPORTANT that
  /// the length returned be somehow transmitted to the decoder. Otherwise, no
  /// decoding is possible.
  int opus_custom_encode_float(
    ffi.Pointer<OpusCustomEncoder> st,
    ffi.Pointer<ffi.Float> pcm,
    int frame_size,
    ffi.Pointer<ffi.UnsignedChar> compressed,
    int maxCompressedBytes,
  ) {
    return _opus_custom_encode_float(
      st,
      pcm,
      frame_size,
      compressed,
      maxCompressedBytes,
    );
  }

  late final _opus_custom_encode_floatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<OpusCustomEncoder>,
              ffi.Pointer<ffi.Float>,
              ffi.Int,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Int)>>('opus_custom_encode_float');
  late final _opus_custom_encode_float =
      _opus_custom_encode_floatPtr.asFunction<
          int Function(ffi.Pointer<OpusCustomEncoder>, ffi.Pointer<ffi.Float>,
              int, ffi.Pointer<ffi.UnsignedChar>, int)>();

  /// Encodes a frame of audio.
  /// @param [in] st <tt>OpusCustomEncoder*</tt>: Encoder state
  /// @param [in] pcm <tt>opus_int16*</tt>: PCM audio in signed 16-bit format (native endian).
  /// There must be exactly frame_size samples per channel.
  /// @param [in] frame_size <tt>int</tt>: Number of samples per frame of input signal
  /// @param [out] compressed <tt>char *</tt>: The compressed data is written here. This may not alias pcm and must be at least maxCompressedBytes long.
  /// @param [in] maxCompressedBytes <tt>int</tt>: Maximum number of bytes to use for compressing the frame
  /// (can change from one frame to another)
  /// @return Number of bytes written to "compressed".
  /// If negative, an error has occurred (see error codes). It is IMPORTANT that
  /// the length returned be somehow transmitted to the decoder. Otherwise, no
  /// decoding is possible.
  int opus_custom_encode(
    ffi.Pointer<OpusCustomEncoder> st,
    ffi.Pointer<opus_int16> pcm,
    int frame_size,
    ffi.Pointer<ffi.UnsignedChar> compressed,
    int maxCompressedBytes,
  ) {
    return _opus_custom_encode(
      st,
      pcm,
      frame_size,
      compressed,
      maxCompressedBytes,
    );
  }

  late final _opus_custom_encodePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<OpusCustomEncoder>,
              ffi.Pointer<opus_int16>,
              ffi.Int,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Int)>>('opus_custom_encode');
  late final _opus_custom_encode = _opus_custom_encodePtr.asFunction<
      int Function(ffi.Pointer<OpusCustomEncoder>, ffi.Pointer<opus_int16>, int,
          ffi.Pointer<ffi.UnsignedChar>, int)>();

  /// Encodes a frame of audio.
  /// @param [in] st <tt>OpusCustomEncoder*</tt>: Encoder state
  /// @param [in] pcm <tt>opus_int32*</tt>: PCM audio in signed 32-bit format (native endian) representing (or slightly exceeding) 24-bit values.
  /// There must be exactly frame_size samples per channel.
  /// @param [in] frame_size <tt>int</tt>: Number of samples per frame of input signal
  /// @param [out] compressed <tt>char *</tt>: The compressed data is written here. This may not alias pcm and must be at least maxCompressedBytes long.
  /// @param [in] maxCompressedBytes <tt>int</tt>: Maximum number of bytes to use for compressing the frame
  /// (can change from one frame to another)
  /// @return Number of bytes written to "compressed".
  /// If negative, an error has occurred (see error codes). It is IMPORTANT that
  /// the length returned be somehow transmitted to the decoder. Otherwise, no
  /// decoding is possible.
  int opus_custom_encode24(
    ffi.Pointer<OpusCustomEncoder> st,
    ffi.Pointer<opus_int32> pcm,
    int frame_size,
    ffi.Pointer<ffi.UnsignedChar> compressed,
    int maxCompressedBytes,
  ) {
    return _opus_custom_encode24(
      st,
      pcm,
      frame_size,
      compressed,
      maxCompressedBytes,
    );
  }

  late final _opus_custom_encode24Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<OpusCustomEncoder>,
              ffi.Pointer<opus_int32>,
              ffi.Int,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Int)>>('opus_custom_encode24');
  late final _opus_custom_encode24 = _opus_custom_encode24Ptr.asFunction<
      int Function(ffi.Pointer<OpusCustomEncoder>, ffi.Pointer<opus_int32>, int,
          ffi.Pointer<ffi.UnsignedChar>, int)>();

  /// Perform a CTL function on an Opus custom encoder.
  ///
  /// Generally the request and subsequent arguments are generated
  /// by a convenience macro.
  /// @see opus_encoderctls
  int opus_custom_encoder_ctl(
    ffi.Pointer<OpusCustomEncoder> st,
    int request,
  ) {
    return _opus_custom_encoder_ctl(
      st,
      request,
    );
  }

  late final _opus_custom_encoder_ctlPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<OpusCustomEncoder>,
              ffi.Int)>>('opus_custom_encoder_ctl');
  late final _opus_custom_encoder_ctl = _opus_custom_encoder_ctlPtr
      .asFunction<int Function(ffi.Pointer<OpusCustomEncoder>, int)>();

  /// Gets the size of an OpusCustomDecoder structure.
  /// @param [in] mode <tt>OpusCustomMode *</tt>: Mode configuration
  /// @param [in] channels <tt>int</tt>: Number of channels
  /// @returns size
  int opus_custom_decoder_get_size(
    ffi.Pointer<OpusCustomMode> mode,
    int channels,
  ) {
    return _opus_custom_decoder_get_size(
      mode,
      channels,
    );
  }

  late final _opus_custom_decoder_get_sizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<OpusCustomMode>,
              ffi.Int)>>('opus_custom_decoder_get_size');
  late final _opus_custom_decoder_get_size = _opus_custom_decoder_get_sizePtr
      .asFunction<int Function(ffi.Pointer<OpusCustomMode>, int)>();

  /// Initializes a previously allocated decoder state
  /// The memory pointed to by st must be the size returned by opus_custom_decoder_get_size.
  /// This is intended for applications which use their own allocator instead of malloc.
  /// @see opus_custom_decoder_create(),opus_custom_decoder_get_size()
  /// To reset a previously initialized state use the OPUS_RESET_STATE CTL.
  /// @param [in] st <tt>OpusCustomDecoder*</tt>: Decoder state
  /// @param [in] mode <tt>OpusCustomMode *</tt>: Contains all the information about the characteristics of
  /// the stream (must be the same characteristics as used for the
  /// encoder)
  /// @param [in] channels <tt>int</tt>: Number of channels
  /// @return OPUS_OK Success or @ref opus_errorcodes
  int opus_custom_decoder_init(
    ffi.Pointer<OpusCustomDecoder> st,
    ffi.Pointer<OpusCustomMode> mode,
    int channels,
  ) {
    return _opus_custom_decoder_init(
      st,
      mode,
      channels,
    );
  }

  late final _opus_custom_decoder_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<OpusCustomDecoder>,
              ffi.Pointer<OpusCustomMode>,
              ffi.Int)>>('opus_custom_decoder_init');
  late final _opus_custom_decoder_init =
      _opus_custom_decoder_initPtr.asFunction<
          int Function(ffi.Pointer<OpusCustomDecoder>,
              ffi.Pointer<OpusCustomMode>, int)>();

  /// Creates a new decoder state. Each stream needs its own decoder state (can't
  /// be shared across simultaneous streams).
  /// @param [in] mode <tt>OpusCustomMode</tt>: Contains all the information about the characteristics of the
  /// stream (must be the same characteristics as used for the encoder)
  /// @param [in] channels <tt>int</tt>: Number of channels
  /// @param [out] error <tt>int*</tt>: Returns an error code
  /// @return Newly created decoder state.
  ffi.Pointer<OpusCustomDecoder> opus_custom_decoder_create(
    ffi.Pointer<OpusCustomMode> mode,
    int channels,
    ffi.Pointer<ffi.Int> error,
  ) {
    return _opus_custom_decoder_create(
      mode,
      channels,
      error,
    );
  }

  late final _opus_custom_decoder_createPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OpusCustomDecoder> Function(ffi.Pointer<OpusCustomMode>,
              ffi.Int, ffi.Pointer<ffi.Int>)>>('opus_custom_decoder_create');
  late final _opus_custom_decoder_create =
      _opus_custom_decoder_createPtr.asFunction<
          ffi.Pointer<OpusCustomDecoder> Function(
              ffi.Pointer<OpusCustomMode>, int, ffi.Pointer<ffi.Int>)>();

  /// Destroys a decoder state.
  /// @param[in] st <tt>OpusCustomDecoder*</tt>: State to be freed.
  void opus_custom_decoder_destroy(
    ffi.Pointer<OpusCustomDecoder> st,
  ) {
    return _opus_custom_decoder_destroy(
      st,
    );
  }

  late final _opus_custom_decoder_destroyPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<OpusCustomDecoder>)>>(
      'opus_custom_decoder_destroy');
  late final _opus_custom_decoder_destroy = _opus_custom_decoder_destroyPtr
      .asFunction<void Function(ffi.Pointer<OpusCustomDecoder>)>();

  /// Decode an opus custom frame with floating point output
  /// @param [in] st <tt>OpusCustomDecoder*</tt>: Decoder state
  /// @param [in] data <tt>char*</tt>: Input payload. Use a NULL pointer to indicate packet loss
  /// @param [in] len <tt>int</tt>: Number of bytes in payload
  /// @param [out] pcm <tt>float*</tt>: Output signal (interleaved if 2 channels). length
  /// is frame_size*channels*sizeof(float)
  /// @param [in] frame_size Number of samples per channel of available space in *pcm.
  /// @returns Number of decoded samples or @ref opus_errorcodes
  int opus_custom_decode_float(
    ffi.Pointer<OpusCustomDecoder> st,
    ffi.Pointer<ffi.UnsignedChar> data,
    int len,
    ffi.Pointer<ffi.Float> pcm,
    int frame_size,
  ) {
    return _opus_custom_decode_float(
      st,
      data,
      len,
      pcm,
      frame_size,
    );
  }

  late final _opus_custom_decode_floatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<OpusCustomDecoder>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Int,
              ffi.Pointer<ffi.Float>,
              ffi.Int)>>('opus_custom_decode_float');
  late final _opus_custom_decode_float =
      _opus_custom_decode_floatPtr.asFunction<
          int Function(
              ffi.Pointer<OpusCustomDecoder>,
              ffi.Pointer<ffi.UnsignedChar>,
              int,
              ffi.Pointer<ffi.Float>,
              int)>();

  /// Decode an opus custom frame
  /// @param [in] st <tt>OpusCustomDecoder*</tt>: Decoder state
  /// @param [in] data <tt>char*</tt>: Input payload. Use a NULL pointer to indicate packet loss
  /// @param [in] len <tt>int</tt>: Number of bytes in payload
  /// @param [out] pcm <tt>opus_int16*</tt>: Output signal (interleaved if 2 channels). length
  /// is frame_size*channels*sizeof(opus_int16)
  /// @param [in] frame_size Number of samples per channel of available space in *pcm.
  /// @returns Number of decoded samples or @ref opus_errorcodes
  int opus_custom_decode(
    ffi.Pointer<OpusCustomDecoder> st,
    ffi.Pointer<ffi.UnsignedChar> data,
    int len,
    ffi.Pointer<opus_int16> pcm,
    int frame_size,
  ) {
    return _opus_custom_decode(
      st,
      data,
      len,
      pcm,
      frame_size,
    );
  }

  late final _opus_custom_decodePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<OpusCustomDecoder>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Int,
              ffi.Pointer<opus_int16>,
              ffi.Int)>>('opus_custom_decode');
  late final _opus_custom_decode = _opus_custom_decodePtr.asFunction<
      int Function(ffi.Pointer<OpusCustomDecoder>,
          ffi.Pointer<ffi.UnsignedChar>, int, ffi.Pointer<opus_int16>, int)>();

  /// Decode an opus custom frame
  /// @param [in] st <tt>OpusCustomDecoder*</tt>: Decoder state
  /// @param [in] data <tt>char*</tt>: Input payload. Use a NULL pointer to indicate packet loss
  /// @param [in] len <tt>int</tt>: Number of bytes in payload
  /// @param [out] pcm <tt>opus_int32*</tt>: Output signal (interleaved if 2 channels) representing (or slightly exceeding) 24-bit values. length
  /// is frame_size*channels*sizeof(opus_int32)
  /// @param [in] frame_size Number of samples per channel of available space in *pcm.
  /// @returns Number of decoded samples or @ref opus_errorcodes
  int opus_custom_decode24(
    ffi.Pointer<OpusCustomDecoder> st,
    ffi.Pointer<ffi.UnsignedChar> data,
    int len,
    ffi.Pointer<opus_int32> pcm,
    int frame_size,
  ) {
    return _opus_custom_decode24(
      st,
      data,
      len,
      pcm,
      frame_size,
    );
  }

  late final _opus_custom_decode24Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<OpusCustomDecoder>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Int,
              ffi.Pointer<opus_int32>,
              ffi.Int)>>('opus_custom_decode24');
  late final _opus_custom_decode24 = _opus_custom_decode24Ptr.asFunction<
      int Function(ffi.Pointer<OpusCustomDecoder>,
          ffi.Pointer<ffi.UnsignedChar>, int, ffi.Pointer<opus_int32>, int)>();

  /// Perform a CTL function on an Opus custom decoder.
  ///
  /// Generally the request and subsequent arguments are generated
  /// by a convenience macro.
  /// @see opus_genericctls
  int opus_custom_decoder_ctl(
    ffi.Pointer<OpusCustomDecoder> st,
    int request,
  ) {
    return _opus_custom_decoder_ctl(
      st,
      request,
    );
  }

  late final _opus_custom_decoder_ctlPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<OpusCustomDecoder>,
              ffi.Int)>>('opus_custom_decoder_ctl');
  late final _opus_custom_decoder_ctl = _opus_custom_decoder_ctlPtr
      .asFunction<int Function(ffi.Pointer<OpusCustomDecoder>, int)>();
}

final class OpusCustomEncoder extends ffi.Opaque {}

final class OpusCustomDecoder extends ffi.Opaque {}

final class OpusCustomMode extends ffi.Opaque {}

typedef opus_int32 = ffi.Int32;
typedef Dartopus_int32 = int;
typedef opus_int16 = ffi.Int16;
typedef Dartopus_int16 = int;
